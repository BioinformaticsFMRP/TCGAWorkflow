---
title: 'TCGA Workflow: Analyze cancer genomics and epigenomics data using Bioconductor
  packages'
author: Tiago C. Silva, Antonio Colaprico, Catharina Olsen, Fulvio D’Angelo, Gianluca
  Bontempi Michele Ceccarelli , and Houtan Noushmehr
date: "`r Sys.Date()`"
output: 
    html_document:
        toc: true
        theme: paper
        number_sections: false
        toc_depth: 2
        highlight: haddock
bibliography: bibliography.bib

vignette: >
  %\VignetteIndexEntry{ Analyze cancer genomics and epigenomics data using Bioconductor
  packages}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
  %\VignetteDepends{AnnotationHub}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,fig.align="center",dpi = 300, cache = FALSE)
```

```{r, echo=FALSE, results="hide", warning=FALSE,message=FALSE}
suppressPackageStartupMessages({
    library(TCGAbiolinks)
    library(stringr)
    library(SummarizedExperiment)
    library(ELMER)
    library(gaia)
    library(parallel)
    library(ChIPseeker)
    library(ComplexHeatmap)
    library(clusterProfiler)
    library(minet)
    library(c3net)
    library(downloader)
    library(biomaRt)
    library(pathview)
    library(BSgenome.Hsapiens.UCSC.hg19)
    library(MotifDb)
    library(MotIV)
    library(rGADEM)
    library(motifStack)
    library(dnet)
    library(circlize)
    library(c3net)
    library(pbapply)
    library(gplots)
    library(ChIPseeker)
    library(pbapply)
    library(GenomeInfoDb)
    library(ggplot2)
    library(AnnotationHub)
})
```


```{r results='asis', echo=FALSE, message=FALSE,include=FALSE}
matched_met_exp <- function(tumor, n = NULL){
    # get primary solid tumor samples: DNA methylation
    met450k <- TCGAquery(tumor = tumor,"HumanMethylation450", level = 3)
    met450k.tp <- TCGAquery_SampleTypes(unique(unlist(stringr::str_split(met450k$barcode,","))),c("TP"))

    # get primary solid tumor samples: RNAseq
    rnaseq <- TCGAquery(tumor = tumor,c("IlluminaHiSeq_RNASeqV2"),level = 3)
    rnaseq.tp <- TCGAquery_SampleTypes(unique(unlist(stringr::str_split(rnaseq$barcode,","))),c("TP"))

    # Get patients with samples in both platforms
    samples <- unique(substr(rnaseq.tp,1,15)[substr(rnaseq.tp,1,12) %in% substr(met450k.tp,1,12)] )
    if(!is.null(n)) samples <- samples[1:n] # get only n samples
    return(samples)
}
lgg.samples <- matched_met_exp("LGG", n = 10)
gbm.samples <- matched_met_exp("GBM", n = 10)
samples <- c(lgg.samples,gbm.samples)
#-----------------------------------
# 1 - Methylation
# ----------------------------------
# For methylation it is quicker in this case to download the tar.gz file
# and get the samples we want instead of downloading files by files
query.met <- TCGAquery(tumor = c("GBM","LGG"), platform = "HumanMethylation450", level = 3, samples = samples)
TCGAdownload(query.met, samples = samples)
met <- TCGAprepare(query.met,dir = ".", save = FALSE,samples = samples)
met.elmer <- TCGAprepare_elmer(met, platform = "HumanMethylation450")

#-----------------------------------
# 2 - Expression
# ----------------------------------
query.rna <- TCGAquery(tumor = c("GBM","LGG"), platform = "IlluminaHiSeq_RNASeqV2", level = 3)
TCGAdownload(query.rna, samples = samples, type = "rsem.genes.normalized_results")
exp <- TCGAprepare(query.rna,dir = ".", type = "rsem.genes.normalized_results",
                         samples =  samples, save = FALSE)
exp.elmer <- TCGAprepare_elmer(exp, platform = "IlluminaHiSeq_RNASeqV2")


LGGmut <- TCGAquery_maf(tumor = "LGG",archive.name="LGG.IlluminaGA_DNASeq_curated.Level_2.1.4.0")
GBMmut <- TCGAquery_maf(tumor = "GBM", archive.name = "ucsc.edu_GBM.IlluminaGA_DNASeq_automated.Level_2.1.1.0")
mut <- plyr::rbind.fill(LGGmut,GBMmut)

# Filtering mutations in gliomas
EA_pathways <- TCGAbiolinks:::listEA_pathways
Glioma_pathways <- EA_pathways[grep("glioma", tolower(EA_pathways$Pathway)),]
Glioma_signaling <- Glioma_pathways[Glioma_pathways$Pathway == "Glioma Signaling",]
Glioma_signaling_genes <- unlist(strsplit(as.character(Glioma_signaling$Molecules),","))

# For time reasons we will use only 10 genes
mut <- mut[mut$Hugo_Symbol %in% Glioma_signaling_genes[1:10],]

samples <- unique(mut$Tumor_Sample_Barcode)
genes <- unique(mut$Hugo_Symbol)
mat <- matrix(0,length(genes),length(samples))
colnames(mat) <- samples
rownames(mat) <- genes

pb <- txtProgressBar(min = 0, max = nrow(mat), style = 3)

for (i in 1:nrow(mat)) {
    curGene <- rownames(mat)[i]
    setTxtProgressBar(pb, i)
    for (j in 1:ncol(mat)) {
        curSample <- colnames(mat)[j]

        if (length(intersect(mut$Tumor_Sample_Barcode, curSample))==1){
            mat1 <- mut[mut$Tumor_Sample_Barcode == curSample,]
            if (length(intersect(mat1$Hugo_Symbol, curGene))==1){
                mat3 <- mat1[mat1$Hugo_Symbol == curGene,]
                mat[curGene,curSample]<- as.character(mat3$Variant_Type)[1]
            }
        }
    }
}
close(pb)

mat[mat==0] <- ""
colnames(mat) <- substr(colnames(mat),1,12)

mat[is.na(mat)] = ""
#mat = t(as.matrix(mat))
mat[1:3, 1:3]

alter_fun = list(
    background = function(x, y, w, h) {
        grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = "#CCCCCC", col = NA))
    },
    SNP = function(x, y, w, h) {
        grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = "blue", col = NA))
    },
    DEL = function(x, y, w, h) {
        grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = "red", col = NA))
    },
    INS = function(x, y, w, h) {
        grid.rect(x, y, w-unit(0.5, "mm"), h*0.33, gp = gpar(fill = "#008000", col = NA))
    }
)

col = c("INS" = "#008000", "DEL" = "red", "SNP" = "blue")

clin.gbm <- TCGAquery_clinic("gbm", "clinical_patient")
clin.lgg <- TCGAquery_clinic("lgg", "clinical_patient")
clinical <- plyr::rbind.fill(clin.lgg,clin.gbm)
annotation <- clinical[match(colnames(mat),clinical$bcr_patient_barcode),c("disease","radiation_therapy")]
annotation <- HeatmapAnnotation(annotation_height = rep(unit(0.3, "cm"),ncol(annotation)),
                                df = annotation,
                                col = list(disease = c("LGG"="green", "GBM"="orange"),
                                           radiation_therapy = c("YES"="blue","NO"="red",
                                            "[Unknown]"="yellow","[Not Available]"="grey")),
                                annotation_legend_param = list(
                                    title_gp = gpar(fontsize = 16, fontface = "bold"),
                                    labels_gp = gpar(fontsize = 16), # size labels
                                    grid_height = unit(8, "mm")))

png("LGG_GBM_oncoprint.png",width = 800,height = 400)
p <- oncoPrint(mat, get_type = function(x) strsplit(x, ";")[[1]],
          remove_empty_columns = FALSE,
          column_order = NULL, # Do not sort the columns
          alter_fun = alter_fun, col = col,
          row_names_gp = gpar(fontsize = 16),  # set size for row names
          pct_gp = gpar(fontsize = 16), # set size for percentage labels
          axis_gp = gpar(fontsize = 16),# size of axis
          column_title = "OncoPrint for TCGA LGG, genes in Glioma signaling",
          column_title_gp = gpar(fontsize = 22),
          pct_digits = 2,
          row_barplot_width = unit(4, "cm"), #size barplot
          bottom_annotation = annotation,
          heatmap_legend_param = list(title = "Mutations", at = c("DEL", "INS", "SNP"),
                                      labels = c("DEL", "INS", "SNP"),
                                      title_gp = gpar(fontsize = 16, fontface = "bold"),
                                      labels_gp = gpar(fontsize = 16), # size labels
                                      grid_height = unit(8, "mm")
          )
)
draw(p, annotation_legend_side =  "bottom")
dev.off()

# defining common parameters
tumorList <- c("LGG","GBM")
PlatformTumor <- "IlluminaHiSeq_RNASeqV2"
dataType <- "rsem.genes.results"
for(tumor in tumorList){

    pathCancer <- paste0("data",tumor)
    datQuery <- TCGAquery(tumor = tumor, platform = PlatformTumor, level = "3")

    samples <- get(paste0(tolower(tumor),".samples"))

    TCGAdownload(data = datQuery, path = pathCancer, type = dataType, samples = c(samples))

    dataAssy <- TCGAprepare(query = datQuery,
                            dir = pathCancer,
                            type = dataType,
                            save = TRUE,
                            summarizedExperiment = TRUE,
                            samples = c(samples),
                            filename = paste0(tumor,"_",PlatformTumor,".rda"))
}

# loading LGG and GBM rse data
load("LGG_IlluminaHiSeq_RNASeqV2.rda")
tumor <-  "LGG"
pathCancer <- paste0("data",tumor)
PlatformTumor <- "IlluminaHiSeq_RNASeqV2"

dataClin_LGG <- TCGAquery_clinic(tumor = "LGG",
                                 clinical_data_type = "clinical_patient")
dataPrep_LGG <- TCGAanalyze_Preprocessing(object = rse,
                                          cor.cut = 0.6,
                                          filename = "LGG_IlluminaHiSeq_RNASeqV2.png")

load("GBM_IlluminaHiSeq_RNASeqV2.rda")
tumor <-  "GBM"
pathCancer <- paste0("data",tumor)
PlatformTumor <- "IlluminaHiSeq_RNASeqV2"

dataClin_GBM <- TCGAquery_clinic(tumor = "GBM",
                                 clinical_data_type = "clinical_patient")

dataPrep_GBM <- TCGAanalyze_Preprocessing(object = rse,
                                          cor.cut = 0.6,
                                          filename = "GBM_IlluminaHiSeq_RNASeqV2.png")

dataNorm <- TCGAanalyze_Normalization(tabDF = cbind(dataPrep_LGG, dataPrep_GBM),
                                      geneInfo = geneInfo,
                                      method = "gcContent") #18323   672

dataFilt <- TCGAanalyze_Filtering(tabDF = dataNorm,
                                  method = "quantile",
                                  qnt.cut =  0.25)  # 13742   672

save(dataFilt, file = paste0("LGG_GBM_Norm_",PlatformTumor,".rda"))

dataFiltLGG <- subset(dataFilt, select = substr(colnames(dataFilt),1,12) %in% dataClin_LGG$bcr_patient_barcode)
dataFiltGBM <- subset(dataFilt, select = substr(colnames(dataFilt),1,12) %in% dataClin_GBM$bcr_patient_barcode)

dataDEGs <- TCGAanalyze_DEA(mat1 = dataFiltLGG, mat2 = dataFiltGBM,
                            Cond1type = "LGG", Cond2type = "GBM",
                            fdr.cut = 0.01 , logFC.cut = 1,
                            method = "glmLRT")

#-------------------  4.2 EA: enrichment analysis             --------------------
ansEA <- TCGAanalyze_EAcomplete(TFname="DEA genes LGG Vs GBM",  RegulonList = rownames(dataDEGs))

png("ea.png", width = 800,height = 800)
TCGAvisualize_EAbarplot(tf = rownames(ansEA$ResBP),
                        GOBPTab = ansEA$ResBP, GOCCTab = ansEA$ResCC,
                        GOMFTab = ansEA$ResMF, PathTab = ansEA$ResPat,
                        nRGTab = rownames(dataDEGs),filename = NULL,
                        nBar = 20)
dev.off()
#-------------------  4.3 PEA:Pathways enrichment analysis      ------------------
# Loading rse object with rnaSEQ gene expression
GenelistComplete <- rownames(assay(rse,1))

# DEGs table with expression values in LGG and GBM samples
dataDEGsFiltLevel <- TCGAanalyze_LevelTab(dataDEGs,"LGG","GBM",
                                          dataFilt[,colnames(dataFiltLGG)],
                                          dataFilt[,colnames(dataFiltGBM)])

dataDEGsFiltLevel$GeneID <- 0

# Converting Gene symbol to gene ID
eg = as.data.frame(bitr(dataDEGsFiltLevel$mRNA,
                        fromType="SYMBOL",
                        toType="ENTREZID",
                        OrgDb="org.Hs.eg.db"))
eg <- eg[!duplicated(eg$SYMBOL),]

dataDEGsFiltLevel <- dataDEGsFiltLevel[dataDEGsFiltLevel$mRNA %in% eg$SYMBOL,]

dataDEGsFiltLevel <- dataDEGsFiltLevel[order(dataDEGsFiltLevel$mRNA,decreasing=FALSE),]
eg <- eg[order(eg$SYMBOL,decreasing=FALSE),]

# table(eg$SYMBOL == dataDEGsFiltLevel$mRNA) should give all TRUE
all(eg$SYMBOL == dataDEGsFiltLevel$mRNA)
dataDEGsFiltLevel$GeneID <- eg$ENTREZID

dataDEGsFiltLevel_sub <- subset(dataDEGsFiltLevel, select = c("GeneID", "logFC"))
genelistDEGs <- as.numeric(dataDEGsFiltLevel_sub$logFC)
names(genelistDEGs) <- dataDEGsFiltLevel_sub$GeneID

require("pathview")
# pathway.id: hsa05214 is the glioma pathway
# limit: sets the limit for gene expression legend and color
hsa05214 <- pathview(gene.data  = genelistDEGs,
                     pathway.id = "hsa05214",
                     species    = "hsa",
                     limit      = list(gene=as.integer(max(abs(genelistDEGs)))))

# remove probes with NA (similar to na.omit)
met <- subset(met,subset = (rowSums(is.na(assay(met))) == 0))

# remove probes in chromossomes X, Y and NA
met <- subset(met,subset = !as.character(seqnames(met)) %in% c("chrNA","chrX","chrY"))


TCGAvisualize_meanMethylation(met,
                              groupCol = "disease", width = 8, height = 8,dpi = 300,
                              group.legend  = "Groups",
                              filename = "mean_lgg_gbm.png",
                              print.pvalue = TRUE)
#-------  5.2 Searching for differentially methylated CpG sites     ----------
# Becareful! Depending on the number of probes and samples this function might take some days.
# But to accelerate the process we use only the chromosome 9
# This should take some minutes
met.chr9 <- subset(met,subset = as.character(seqnames(met)) %in% c("chr9"))

met.chr9 <- TCGAanalyze_DMR(met.chr9,
                       groupCol = "disease", # a column in the colData matrix
                       group1 = "GBM",       # a type of the the groupCol column
                       group2="LGG",         # a type of the the groupCol column
                       p.cut = 10^-2,
                       diffmean.cut = 0.25,
                       legend = "State",
                       plot.filename = "LGG_GBM_metvolcano.png",
                       cores = 1 # if set to 1 there will be a progress bar
)

#--------------------------
# DNA Methylation heatmap
#-------------------------

# get the probes that are Hypermethylated or Hypomethylated
# met is the same object of the section 'DNA methylation analysis'
sig.met <- met.chr9[values(met.chr9)$status.GBM.LGG %in% c("Hypermethylated","Hypomethylated"),]

# To speed up the example, let take a look on the first 100 probes
sig.met.100 <- sig.met[1:100,]

# top annotation, which sampples are LGG and GBM
# We will add clinical data as annotation of the samples
# we will sort the clinical data to have the same order of the DNA methylation matrix
clinical.order <- clinical[match(substr(colnames(sig.met.100),1,12),clinical$bcr_patient_barcode),]
ta = HeatmapAnnotation(df = clinical.order[,c("disease","gender","icd_o_3_histology","tumor_tissue_site")],
                       col = list(disease = c("LGG" = "grey", "GBM" = "black"),
                                  gender = c("MALE"="blue","FEMALE"="pink")))

# row annotation: add the status for LGG in relation to GBM
# For exmaple: status.gbm.lgg Hypomethyated means that the mean DNA methylation of
# probes for lgg are hypomethylated compared to GBM ones.
ra = rowAnnotation(df = values(sig.met.100)["status.GBM.LGG"],
                   col = list(status.GBM.LGG = c("Hypomethylated" = "orange",
                                                 "Hypermethylated" = "darkgreen")),
                   width = unit(1, "cm"))

heatmap  <- Heatmap(assay(sig.met.100),
                    name = "DNA methylation",
                    top_annotation = ta,
                    col = matlab::jet.colors(200),
                    show_row_names = F,
                    cluster_rows = T,
                    cluster_columns = F,
                    show_column_names = F,
                    column_title = "DNA Methylation") + ra
png("heatmap.png",width = 600, height = 400); draw(heatmap); dev.off()

geneAnnot <- txs()
geneAnnot$GENEID <- paste0("ID",geneAnnot$GENEID)
geneInfo <- promoters(geneAnnot,upstream = 0, downstream = 0)
probe <- get.feature.probe()

# create mee object, use @ to access the matrices inside the object
mee <- fetch.mee(meth = met.elmer, exp = exp.elmer, TCGA = TRUE, probeInfo = probe, geneInfo = geneInfo)

# Get lgg barcodes
samples <- unlist(str_split(TCGAquery("gbm", "HumanMethylation450", level = 3)$barcode,","))

# Relabel LGG samples in the mee object: GBM is control
mee@sample$TN[mee@sample$ID %in% lgg.samples] <- "Control"
save(mee,file = "mee.rda")

# Available directions are hypo and hyper, we will use only hypo
# due to speed constraint
direction <- c("hypo")

for (j in direction){
    print(j)
    dir.out <- paste0("elmer/",j)
    dir.create(dir.out, recursive = TRUE)
    #--------------------------------------
    # STEP 3: Analysis                     |
    #--------------------------------------
    # Step 3.1: Get diff methylated probes |
    #--------------------------------------
    Sig.probes <- get.diff.meth(mee, cores=detectCores(),
                                dir.out =dir.out,
                                diff.dir=j,
                                pvalue = 0.01)

    #-------------------------------------------------------------
    # Step 3.2: Identify significant probe-gene pairs            |
    #-------------------------------------------------------------
    # Collect nearby 20 genes for Sig.probes
    nearGenes <- GetNearGenes(TRange=getProbeInfo(mee, probe=Sig.probes$probe),
                              cores=detectCores(),
                              geneAnnot=getGeneInfo(mee))

    pair <- get.pair(mee=mee,
                     probes=Sig.probes$probe,
                     nearGenes=nearGenes,
                     permu.dir=paste0(dir.out,"/permu"),
                     dir.out=dir.out,
                     cores=detectCores(),
                     label= j,
                     permu.size=100, # For significant results use 10000
                     Pe = 0.01) # For significant results use 0.001

    Sig.probes.paired <- fetch.pair(pair=pair,
                                    probeInfo = getProbeInfo(mee),
                                    geneInfo = getGeneInfo(mee))
    Sig.probes.paired <-read.csv(paste0(dir.out,"/getPair.",j,".pairs.significant.csv"),
                                 stringsAsFactors=FALSE)[,1]


    #-------------------------------------------------------------
    # Step 3.3: Motif enrichment analysis on the selected probes |
    #-------------------------------------------------------------
    if(length(Sig.probes.paired) > 0 ){
        #-------------------------------------------------------------
        # Step 3.3: Motif enrichment analysis on the selected probes |
        #-------------------------------------------------------------
        enriched.motif <- get.enriched.motif(probes=Sig.probes.paired,
                                             dir.out=dir.out, label=j,
                                             background.probes = probe$name)
        motif.enrichment <- read.csv(paste0(dir.out,"/getMotif.",j,".motif.enrichment.csv"),
                                     stringsAsFactors=FALSE)
        if(length(enriched.motif) > 0){
            #-------------------------------------------------------------
            # Step 3.4: Identifying regulatory TFs                        |
            #-------------------------------------------------------------
            print("get.TFs")

            TF <- get.TFs(mee = mee,
                          enriched.motif = enriched.motif,
                          dir.out = dir.out,
                          cores = detectCores(), label = j)
            TF.meth.cor <- get(load(paste0(dir.out,"/getTF.",j,".TFs.with.motif.pvalue.rda")))
            save(TF, enriched.motif, Sig.probes.paired,
                 pair, nearGenes, Sig.probes, motif.enrichment, TF.meth.cor,
                 file=paste0(dir.out,"/ELMER_results_",j,".rda"))
        }
    }
}
png("TF.png",width = 800, height = 400)
scatter.plot(mee, category="TN", save=T, lm_line=TRUE,
             byTF=list(TF=c("WT1","ZNF208","ATF4","DDX5"), probe=enriched.motif[["AP1"]]))
dev.off()

TCGAsurvival_TFplot <- function(TF,mee, clinical, percentage = 0.3){

    # For the transcription factor, gets it getGeneID
    gene <- getGeneID(mee,symbol=TF)
    # Get the expression values for the genes.
    # (getExp is a ELMER function)
    exp <- getExp(mee,geneID=gene)

    # Get the names of the 30% patients with lower expression
    g1 <- names(sort(exp)[1:ceiling(length(exp) * percentage)])

    # Get the names of the 30% patients with higher expression
    g2 <- names(sort(exp,decreasing = T)[1:ceiling(length(exp) * percentage)])

    # get the data of only these patients
    clinical <- clinical[clinical$bcr_patient_barcode %in% substr(c(g1, g2),1,12),]

    # Create the labels for each sample
    clinical$tf_groups <- "high"
    clinical[clinical$bcr_patient_barcode  %in% substr(c(g1),1,12),]$tf_groups <- "low"

    # Use TCGAbiolinks to create the survival curve
    TCGAanalyze_survival(clinical,"tf_groups",
                         legend=paste0(TF," Exp level"),
                         filename = paste0(TF,".png"))
}

# get clinical patient data for GBM samples
gbm_clin <- TCGAquery_clinic("gbm","clinical_patient")

# get clinical patient data for LGG samples
lgg_clin <- TCGAquery_clinic("lgg","clinical_patient")

# Bind the results, as the columns might not be the same,
# we will will plyr rbind.fill, to have all columns from both files
clinical <- plyr::rbind.fill(gbm_clin,lgg_clin)
# Call the function we created
TCGAsurvival_TFplot("TP53",mee,clinical)
TCGAsurvival_TFplot("FOXP4",mee,clinical)
TCGAsurvival_TFplot("FOXE3",mee,clinical)
```

# Abstract


Biotechnological advances in sequencing have led to an explosion of publicly available data via large international consortia such as 
[The Cancer Genome Atlas (TCGA)](http://cancergenome.nih.gov/), [ENCODE](http://www.encodeproject.org/), and the NIH Roadmap Epigenomics Mapping Consortium [Roadmap](http://www.roadmapepigenomics.org/). These projects have provided unprecedented opportunities to interrogate the epigenome of cultured cancer cell lines as well as normal and tumor tissues with high genomic resolution. The [bioconductor](http://www.bioconductor.org/) project offers more than 1,000 open-source software and statistical packages to analyze high-throughput genomic data. However, most packages are designed for specific data types (e.g. expression, epigenetics, genomics) and there is no one comprehensive tool that provides a complete integrative analysis harnessing the resources and data provided by all three public projects. A need to create an integration of these different analyses was recently proposed. In this workflow, we provide a series of biologically focused integrative downstream analyses of different molecular data. We describe how to download, process and prepare TCGA data and by harnessing several key bioconductor packages, we describe how to extract biologically meaningful genomic and epigenomic data and by using Roadmap and ENCODE data, we provide a workplan to identify candidate biologically relevant functional epigenomic elements associated with cancer. 


To illustrate our workflow, we analyzed two types of brain tumors : low-grade glioma (LGG) versus high-grade glioma (glioblastoma multiform or GBM). But in order to create a repeatable workflow in a short time, for some sections we used only a subset of the data available, always adjusting necessary cutting thresholds, and for other  sections the code was executed only for LGG or GBM, but is designed to easily run both tumor types.

This workflow introduces the following Bioconductor packages:

* [AnnotationHub](http://www.bioconductor.org/packages/AnnotationHub/)
* [ChIPSeeker](http://www.bioconductor.org/packages/ChIPseeker/)
* [ComplexHeatmap](http://www.bioconductor.org/packages/ComplexHeatmap/)
* [pathview](http://www.bioconductor.org/packages/pathview/)
* [ELMER](http://www.bioconductor.org/packages/ELMER/)
* [GAIA](http://www.bioconductor.org/packages/gaia/)
* [MINET](http://www.bioconductor.org/packages/minet/)
* [RTCGAtoolbox](http://www.bioconductor.org/packages/RTCGAtoolbox/)
* [TCGAbiolinks](http://www.bioconductor.org/packages/TCGAbiolinks/)
* [AnnotationHub](http://www.bioconductor.org/packages/GAIA/)

**Keywords:** Epigenomics, Genomics, Cancer, non-coding, TCGA, ENCODE, Roadmap, Bioinformatics.

# Introduction

Cancer is a complex genetic disease spanning multiple molecular events such as point  mutations, structural variations, translocations and activation of epigenetic and transcriptional signatures and networks. The effects of these events take place at different  spatial and temporal scales with interlayer communications and feedback mechanisms creating a highly complex dynamic system. In order to get insight in the the biology of tumours most of the research in cancer genomics is aimed at the integration of the observations at multiple molecular scales and the analysis  of their interplay. Even if many tumors  share similar recurrent genomic events, the understanding of their relationships with the observed phenotype are often not understood. For example, although   we know that the majority  of the most aggressive form of brain tumours such as glioma  harbour the mutation of a single gene (IDH), the mechanistic explanation of the activation of its characteristic   epigenetic and transcriptional signatures are still far to be well characterized. Moreover, network-based strategies have recently emerged as an  effective framework for the discovery functional disease drivers that act as main regulators of cancer phenotypes.
Here we describe a comprehensice workflow that integrates many Bioconductor packages in order to analyze and integrate the molteplicity of molecular observation layers in large scale cancer dataset.

Indeed, recent technological developments allowed the deposition of large amounts of genomic and epigenomic data, such as gene expression, DNA methylation, and genomic localization of transcription factors, into freely available public international consortia like The Cancer Genome Atlas [TCGA](http://cancergenome.nih.gov/), The Encyclopedia of DNA Elements [ENCODE](http://www.encodeproject.org/),  and The NIH Roadmap Epigenomics Mapping Consortium [Roadmap](http://www.roadmapepigenomics.org/) [@Hawkins].  An overview of the three consortia is described below:

* **The Cancer Genome Atlas (TCGA):** The TCGA consortium, which is a  National Institute of Health (NIH) initiative,
makes publicly available molecular and clinical information for more than 30 types of human
cancers that include: exome (variant analysis), single nucleotide polymorphism (SNP),  DNA methylation,
transcriptome (mRNA), microRNA (miRNA), proteome and clinical information.
Sample types available at TCGA are: primary solid tumors, recurrent solid tumors, blood derived normal and tumor,
and solid tissue normal [@weinstein2013cancer].
* **The Encyclopedia of DNA Elements (ENCODE):** Found in 2003 by the National Human Genome Research Institute (NHGRI),
the project aims to build a comprehensive list of functional elements that have an active role in the genome,
including regulatory elements that govern gene expression. Biosamples includes immortalized cell lines, tissues,
primary cells and stem cells [@encode2011user].

* **The NIH Roadmap Epigenomics Mapping Consortium:** This was launched with the goal of producing a
public resource of human epigenomic data in order to analyze biology and disease-oriented research.
Roadmap maps DNA methylation, histone modifications, chromatin accessibility, and small RNA transcripts
in stem cells and primary ex vivo tissues [@Fingerman,@Bernstein].

Briefly, these three consortia provide large scale epigenomic data onto a variety of microarrays and
next-generation sequencing (NGS) platforms. Each consortium encompasses specific types of biological
information on specific type of tissue or cell and when analyzed together, it provides an invaluable opportunity for research laboratories to better understand the developmental progression of normal to cancer state at the molecular level and importantly, correlate these phenotypes with tissue of origins.

Although there exists a wealth of  possibilities [@kannan2015public]  in accessing cancer associated data,  [bioconductor](http://www.bioconductor.org/)  represent the most comprehensive set of open source, updated
and integrated  professional  tools for the statistical analysis of large scale genomic data.
Thus, we propose our workflow within bioconductor to describe how to download, process, analyze and integrate cancer data to understand specific cancer-related specific questions.
However, there is no tool that solves the issue of integration  in a comprehensive sequence and mutation information, epigenomic state and gene expression within the context of gene regulatory networks to identify oncogenic drivers and characterize altered pathways during cancer progression.
 Therefore, our workflow presents several [bioconductor](http://www.bioconductor.org/) packages
 to work with genomic and epigenomics data.


# Methods
## Experimental data

TCGA data is accessible via the [TCGA data portal](https://tcga-data.nci.nih.gov/tcga/)
and the [Broad Institute's GDAC Firehose](gdac.broadinstitute.org).
The data is provided as different levels or tiers: Level 1 (Raw Data),
Level 2 (Processed Data), Level 3 (Segmented or Interpreted Data) and Level 4 (Region of Interest Data).
While the TCGA data portal provides level 1 to 3 data, Firehose only provides level 3 and 4.
An explanation of the different levels can be found at  [TCGA Wikipedia](https://wiki.nci.nih.gov/display/TCGA/Data+level).
The data provided by TCGA data portal can be accessed using Bioconductor package  [TCGAbiolinks](http://bioconductor.org/packages/TCGAbiolinks/),
while the data provided by Firehose can be accessed by Bioconductor package [RTCGAtoolbox](http://bioconductor.org/packages/RTCGAtoolbox/).

The next steps describes how one could use TCGAbiolinks \& RTCGAtoolbox to download clinical,
genomics, transcriptomics, epigenomics data, as well as
subtype information and GISTIC results (identified genes targeted by somatic copy-number alterations (SCNAs)
that drive cancer growth).
Just to reiterate, the data used in this workflow are published data and freely available.

### Downloading data from TCGA data portal

The Bioconductor package  [TCGAbiolinks](http://bioconductor.org/packages/TCGAbiolinks/) [@TCGAbiolinks]
has three main  functions `TCGAquery`, `TCGAdownload` and `TCGAprepare` that should sequentially be used
to respectively  search,   download and  load  the data as an R object.

`TCGAquery` searches in a pre-processed TCGA database and returns a summary table with the found files,
samples, version and other useful information. The most important `TCGAquery` arguments are
*tumor* which receives one or multiple tumor types (USC, LGG, SKCM, KICH, CHO, etc),
*platform* which receives the platform (HumanMethylation27, Genome\_Wide\_SNP\_6, IlluminaHiSeq\_RNASeqV2, etc),
*version* which receives the version of the data to be downloaded if the user wants an older version and
*samples* which receives a list of TCGA barcodes (ex. "TCGA-CS-4938") to filter the search results.
A complete list of possible entries for arguments can be found in the
 [TCGAbiolinks vignette](https://www.bioconductor.org/packages/3.3/bioc/vignettes/TCGAbiolinks/inst/doc/tcgaBiolinks.html#tcgaquery-searching-tcga-open-access-data-for-download).

After searching, the user will be able to download the data with `TCGAdownload`.
An important feature of this function is the ability to filter the data using the
arguments *type* if the user wants to specify file tumor type and *samples* if
user wants to specify samples (list of TCGA barcodes).
The platforms
and their possible inputs for the type argument is shown below:

* **RNASeqV2:** junction\_quantification, rsem.genes.results, rsem.isoforms.results,
         rsem.genes.normalized\_results, rsem.isoforms.normalized\_results, bt.exon\_quantification
* **RNASeq:** exon.quantification, spljxn.quantification, gene.quantification
* **genome\_wide\_snp\_6:** hg18.seg, hg19.seg, nocnv\_,hg18.seg, nocnv\_hg19.seg
* **IlluminaHiSeq\_miRNASeq:** hg19.mirbase20.mirna.quantification, hg19.mirbase20.isoform.quantification,
  mirna.quantification, isoform.quantification

Finally, *TCGAprepare* transforms the downloaded data into a [summarizedExperiment](http://bioconductor.org/packages/SummarizedExperiment/) 
object or a data frame.
 If summarizedExperiment is set to TRUE,
 TCGAbiolinks will add metadata to the object in order to help the user when working with the data. Also,
 if the user sets the argument add.subtype to TRUE the summarizedExperiment will receive subtype information
 defined by The Cancer Genome Atlas (TCGA) Research Network reports (the full list of papers can be seen in
 [TCGAquery\_subtype section](http://bioconductor.org/packages/devel/bioc/vignettes/TCGAbiolinks/inst/doc/tcgaBiolinks.html#tcgaquery_subtype-working-with-molecular-subtypes-data.) in TCGAbiolinks vignette),
Likewise, if the user sets the argument add.clinical to TRUE the summarizedExperiment will receive clinical information.
 Lines 8-11 and 18-22 of listing below illustrates this function.

```{#numCode .R .numberLines}
library(TCGAbiolinks)

# Download the DNA methylation data: HumanMethylation450 LGG and GBM.
path <- "."

query.met <- TCGAquery(tumor = c("LGG","GBM"),"HumanMethylation450", level = 3)
TCGAdownload(query.met, path = path )
met <- TCGAprepare(query = query.met,dir = path,
                   add.subype = TRUE, add.clinical = TRUE,
                   summarizedExperiment = TRUE,
                   save = TRUE, filename = "lgg_gbm_met.rda")

# Download the expression data: IlluminaHiSeq_RNASeqV2 LGG and GBM.
query.exp <- TCGAquery(tumor = c("lgg","gbm"), platform = "IlluminaHiSeq_RNASeqV2",level = 3)

TCGAdownload(query.exp,path = path, type = "rsem.genes.normalized_results")

exp <- TCGAprepare(query = query.exp, dir = path,
                   summarizedExperiment = TRUE,
                   add.subype = TRUE, add.clinical = TRUE,
                   type = "rsem.genes.normalized_results",
                   save = T,filename = "lgg_gbm_exp.rda")
```

If a summarizedExperiment object was chosen, the data can be accessed with three different accessors:
*assay* for the data information, *rowRanges* to gets the range of values in each row and
*colData* to get the sample information (patient, batch, sample type, etc) [@huber2015orchestrating,@SummarizedExperiment].
An example is shown in listing below.


```{#numCode .R .numberLines}
library(summarizedExperiment)
# get expression matrix
data <- assay(exp)

# get sample information
sample.info <- colData(exp)

# get genes information
genes.info <- rowRanges(exp)
```

Clinical data can be obtained using the function `TCGAquery_clinical` which can be used as
described in listing below. This function has three arguments *tumor*, *clinical\_data\_type* and *samples*.
The *clinical\_data\_type* argument is always required and should be accompanied by at least one of the other two parameters.
Examples for the argument clinical\_data\_type are: "clinical\_drug", "clinical\_patient",and "clinical\_radiation"
(a complete list and description can be found in the section 'Working with clinical data.' of the TCGAbiolinks [vignette](https://bioconductor.org/packages/3.4/bioc/vignettes/TCGAbiolinks/inst/doc/tcgaBiolinks.html#tcgaquery_clinic-tcgaquery_clinicfilt-working-with-clinical-data.).

**Clinical data: important note**

Follow-up data (in biotab format) for TCGA patients are contained in the ‘clinical_follow_up’ files for each cancer type. The different versions of the follow-up files represent changes or new data added to follow-up forms over time. Multiple follow-up files for a single patient often represent a series of follow-ups over a period of time. However, multiple instances of the same follow-up file can also represent multiple new tumor events within the same time period. To obtain all available disease progression information, please use ALL of the follow_up files in your analyses, not just the latest version.

```{#numCode .R .numberLines}
  # get clinical patient data for GBM samples
  gbm_clin <- TCGAquery_clinic("gbm","clinical_patient")

  # get clinical patient data for LGG samples
  lgg_clin <- TCGAquery_clinic("lgg","clinical_patient")

  # Bind the results, as the columns might not be the same,
  # we will will plyr rbind.fill, to have all columns from both files
  clinical <- plyr::rbind.fill(gbm_clin,lgg_clin)

  # Other clinical files can be downloaded,
  # Use ?TCGAquery_clinic for more information
  clin_radiation <- TCGAquery_clinic("lgg","clinical_radiation")

  # Also, you can get clinical information from different tumor types.
  # For example sample 1 is GBM, sample 2 and 3 are TGCT
  data <- TCGAquery_clinic(clinical_data_type = "clinical_patient",
                           samples = c("TCGA-06-5416-01A-01D-1481-05",
                                       "TCGA-2G-AAEW-01A-11D-A42Z-05",
                                       "TCGA-2G-AAEX-01A-11D-A42Z-05"))
```

Mutation information is stored in Mutation Annotation Format (MAF) files which contain different mutation types (somatic or germline)
and states (validated or putative). A summary of all the Mutation Annotation Format (MAF) can be accessed at
[TCGA wiki](https://wiki.nci.nih.gov/display/TCGA/TCGA+MAF+Files).
To download this data using  [TCGAbiolinks](http://bioconductor.org/packages/TCGAbiolinks/),
`TCGAquery_maf` function is provided. It will download the non-obsolete tables from TCGA wiki,
remove the protected entries and ask the user which file s/he wants to download (see listing below).
It will then download and return a data frame with the data.

```{#numCode .R .numberLines}
  > mutation <- TCGAquery_maf(tumor = "lgg")
  Getting maf tables
  Source: https://wiki.nci.nih.gov/display/TCGA/TCGA+MAF+Files
  We found these maf files below:
                                                            MAF.File.Name
  2                      hgsc.bcm.edu_LGG.IlluminaGA_DNASeq.1.somatic.maf
  3   LGG_FINAL_ANALYSIS.aggregated.capture.tcga.uuid.curated.somatic.maf

                                                    Archive.Name Deploy.Date
  2   hgsc.bcm.edu_LGG.IlluminaGA_DNASeq_automated.Level_2.1.0.0   10-DEC-13
  3    broad.mit.edu_LGG.IlluminaGA_DNASeq_curated.Level_2.1.3.0   24-DEC-14

  Please, select the line that you want to download: 3
```

Finally, the Cancer Genome Atlas (TCGA) Research Network has reported integrated genome-wide studies of various diseases, in what is called `PanCan'.
*TCGAqueryPrepare* function can automatically import the subtypes defined by these reports and incorporate them into a summarizedExperiment object. The subtypes can also be accessed using *TCGAquery\_subtype* function. The subtypes include:
LGG [@Cell], GBM [@Cell],
STAD [@cancer2014comprehensive_gastric], BRCA [@cancer2012comprehensive_brca],
READ [@cancer2012comprehensive_colon], COAD [@cancer2012comprehensive_colon] and
LUAD [@cancer2014comprehensive_lung].

```{#numCode .R .numberLines}
gbm.subtypes <- TCGAquery_subtype(tumor = "gbm")
brca.subtypes <- TCGAquery_subtype(tumor = "brca")
```

### Downloading data from Broad TCGA GDAC

The Bioconductor package [RTCGAtoolbox](http://bioconductor.org/packages/RTCGAtoolbox/) [@samur2014rtcgatoolbox]
provides access to Firehose Level 3 and 4 data through the function `getFirehoseData`.
The following arguments allows users to select the version and tumor type of interest:


* dataset - Tumor to download. A complete list of possibilities are listed in `getFirehoseDatasets` function.
* runDate - Stddata run dates. Dates can be viewed with `getFirehoseRunningDates` function.
* gistic2\_Date - Analyze run dates. Dates can viewed with`getFirehoseAnalyzeDates` function.

These arguments can be used to select the data type to download: RNAseq\_Gene, Clinic, miRNASeq\_Gene,
ccRNAseq2\_Gene\_Norm, CNA\_SNP, CNV\_SNP, CNA\_Seq, CNA\_CGH, Methylation, Mutation, mRNA\_Array ,
miRNA\_Array, and RPPA.

By default, RTCGAtoolbox allows users to download up to 500 MB worth of data.
To increase the size of the download, users are encouraged to use **fileSizeLimit** argument.
An example is found in listing below.
The `getData` function allow users to access the downloaded data (see lines 22-24 of listing below) as a S4Vector object.


```{#numCode .R .numberLines}
library(RTCGAToolbox)

# Get the last run dates
lastRunDate <- getFirehoseRunningDates()[1]
lastAnalyseDate <- getFirehoseAnalyzeDates(1)

# get DNA methylation data, RNAseq2 and clinical data for LGG
lgg.data <- getFirehoseData(dataset = "LGG",
                            gistic2_Date = getFirehoseAnalyzeDates(1), runDate = lastRunDate,
                            Methylation = TRUE, RNAseq2_Gene_Norm = TRUE, Clinic = TRUE,
                            Mutation = T,
                            fileSizeLimit = 10000)

# get DNA methylation data, RNAseq2 and clinical data for GBM
gbm.data <- getFirehoseData(dataset = "GBM",
                            runDate = lastDate, gistic2_Date = getFirehoseAnalyzeDates(1),
                            Methylation = TRUE, Clinic = TRUE, RNAseq2_Gene_Norm = TRUE,
                            fileSizeLimit = 10000)

# To access the data you should use the getData function
# or simply access with @ (for example gbm.data@Clinical)
gbm.mut <- getData(gbm.data,"Mutations")
gbm.clin <- getData(gbm.data,"Clinical")
gbm.gistic <- getData(gbm.data,"GISTIC")
```

Finnaly, RTCGAtoolbox can access level 4 data, which can be handy when the user requires GISTIC results.
 GISTIC is used to identify genes targeted by somatic copy-number alterations (SCNAs) [@mermel2011gistic2].

```{#numCode .R .numberLines}
# Download GISTIC results
gistic <- getFirehoseData("GBM",gistic2_Date ="20141017" )

# get GISTIC results
gistic.allbygene <- gistic@GISTIC@AllByGene
gistic.thresholedbygene <- gistic@GISTIC@ThresholedByGene
```


## Genomic analysis

Copy number variations (CNV) has a critical role in cancer development and progression. A chromosomal segment can be deleted or amplified as a result of genomic rearrangements, such as deletions, duplications, insertions and translocations. CNV are genomic regions greater than 1 kb with an alteration of copy number between two conditions, e.g. Tumor *versus* Normal.

TCGA collects copy number data and allows the CNV profiling of cancer.
Tumor and paired-normal DNA samples were analysed for CNV detection using microarray- and sequencing-based technologies.
Level 3 processed data are the aberrant regions along the genome resulting from CNV segmentation,
and they are available for all copy number technologies.

In this section, we will show how to analyze CNV level 3 data from TCGA to identify recurrent alterations in cancer genome.
We analyzed LGG segmented CNV from SNP array (Affymetrix Genome-Wide Human SNP Array 6.0).

### Pre-Processing Data
The only CNV platform available for both LGG and GBM in TCGA is "Affymetrix Genome-Wide Human SNP Array 6.0". Using TCGAbiolinks, we queried for CNV SNP6 level 3 data for primary solid tumor samples. Data for selected samples were downloaded and prepared in  separate objects (RangedSummarizedExperiment).

```{r results='asis', echo=FALSE, message=FALSE,warning=FALSE,include=FALSE}
library(TCGAbiolinks)
library(GenomicRanges)
library(biomaRt)
library(gaia)
# Select common CN technology available for GBM and LGG
# To make this workflow faster we will run it only for LGG samples
# To use it for LGG and GBM set use:
# tumorList <- c("LGG","GBM")
tumorList <- c("LGG")
PlatformTumor <- "Genome_Wide_SNP_6"
dataType <- "nocnv_hg19"

for(tumor in tumorList){
    pathCancer <- paste0("data",tumor)
    datQuery <- TCGAquery(tumor = tumor, platform = PlatformTumor, level = "3")
    lsSample <- TCGAquery_samplesfilter(query = datQuery)
    selected <- TCGAquery_SampleTypes(barcode = lsSample$Genome_Wide_SNP_6, typesample = "TP")[1:200]

    TCGAdownload(data = datQuery, path = pathCancer, type = dataType, samples = selected)

    dataAssay <- TCGAprepare(query = datQuery,
                             dir = pathCancer,
                             type = dataType,
                             save = FALSE,
                             summarizedExperiment = TRUE,
                             samples = selected)
    save(PlatformTumor, tumor, pathCancer, selected, dataAssay, file = paste0(tumor,"_",PlatformTumor,".rda"))
}
```

```{#numCode .R .numberLines}
library(TCGAbiolinks)
library(GenomicRanges)
library(biomaRt)
library(gaia)
# Select common CN technology available for GBM and LGG
# To make this workflow faster we will run it only for LGG samples
# To use it for LGG and GBM set use:
# tumorList <- c("LGG","GBM")
tumorList <- c("LGG")
PlatformTumor <- "Genome_Wide_SNP_6"
dataType <- "nocnv_hg19"

for(tumor in tumorList){
    pathCancer <- paste0("data",tumor)
    datQuery <- TCGAquery(tumor = tumor, platform = PlatformTumor, level = "3")
    lsSample <- TCGAquery_samplesfilter(query = datQuery)
    # We will use only 200 samples to make the example faster, remove [1:200] to use all samples
    selected <- TCGAquery_SampleTypes(barcode = lsSample$Genome_Wide_SNP_6, typesample = "TP")[1:200]

    TCGAdownload(data = datQuery, path = pathCancer, type = dataType, samples = selected)

    dataAssay <- TCGAprepare(query = datQuery,
                             dir = pathCancer,
                             type = dataType,
                             save = TRUE,
                             summarizedExperiment = TRUE,
                             samples = selected)
    save(PlatformTumor, tumor, pathCancer, selected, dataAssay, file = paste0(tumor,"_",PlatformTumor,".rda"))
}
```


### Identification of recurrent CNV in cancer
Cancer related CNV have to be present in many of the analyzed genomes. The most significant recurrent CNV were identified using [GAIA](http://bioconductor.org/packages/gaia/) [@morganellagaia], an iterative procedure where a statistical hypothesis framework is extended to take into account within-sample homogeneity. GAIA is based on a conservative permutation test allowing the estimation of the probability distribution of the contemporary mutations expected for non-driver markers.

Segmented data retrieved from TCGA were used to generate a matrix including all needed information about the observed aberrant regions. Furthermore, GAIA requires genomic probes metadata (specific for each CNV technology), that can be downloaded from broadinstitute website.

```{r results='asis', echo=TRUE, message=FALSE,warning=FALSE}
#--------------------      Internal functions     ----------------------------
gaiaCNVplot <- function (calls, tumor=NULL, threshold=0.01)
{
    Calls <- calls[order(calls[,"Region Start [bp]"]),]
    Calls <- Calls[order(Calls[,"Chromosome"]),]
    rownames(Calls) <- NULL
    Chromo <- Calls[,"Chromosome"]
    Gains <- apply(Calls,1,function(x) ifelse(x["Aberration Kind"]==1, x["score"], 0))
    Losses <- apply(Calls,1,function(x) ifelse(x["Aberration Kind"]==0, x["score"], 0))
    plot(Gains, ylim = c(-max(Calls[,"score"]+2), max(Calls[,"score"]+2)), type = "h",
         col = "red", xlab = "Chromosome", ylab = "Score",
         #main = paste("Recurrent Copy Number Variations",tumor, sep=" - "),
         xaxt = "n")
    points(-(Losses), type = "h", col = "blue")
    abline(h = 0, cex = 4)
    abline(h = -log10(threshold), col = "orange", cex = 4, main="test")
    abline(h = log10(threshold), col = "orange", cex = 4, main="test")
    uni.chr <- unique(Chromo)
    temp <- rep(0, length(uni.chr))
    for (i in 1:length(uni.chr)) {
        temp[i] <- max(which(uni.chr[i] == Chromo))
    }
    for (i in 1:length(temp)) {
        abline(v = temp[i], col = "black", lty = "dashed", )
    }
    nChroms <- length(uni.chr)
    begin <- c()
    for (d in 1:nChroms) {
        chrom <- sum(Chromo == uni.chr[d])
        begin <- append(begin, chrom)
    }
    temp2 <- rep(0, nChroms)
    for (i in 1:nChroms) {
        if (i == 1) {
            temp2[1] <- (begin[1] * 0.5)
        }
        else if (i > 1) {
            temp2[i] <- temp[i - 1] + (begin[i] * 0.5)
        }
    }
    uni.chr[uni.chr==23] <- "X"
    uni.chr[uni.chr==24] <- "Y"
    for (i in 1:length(temp)) {
        axis(1, at = temp2[i], labels = uni.chr[i], cex.axis = 1)
    }
    legend(x=1,y=max(Calls[,"score"]+2), y.intersp=0.8, c("Amp"), pch=15, col=c("red"), text.font=3)
    legend(x=1,y=-max(Calls[,"score"]+0.5), y.intersp=0.8, c("Del"), pch=15, col=c("blue"), text.font=3)
}

#--------------------     Get gene information     ----------------------------
mart <- useMart(biomart="ensembl", dataset="hsapiens_gene_ensembl")
genes <- getBM(attributes = c("hgnc_symbol", "chromosome_name","start_position","end_position"), mart=mart)
genes <- genes[genes[,1]!="" & genes[,2]%in%c(1:22,"X","Y"),]
xidx <- which(genes[,2]=="X")
yidx <- which(genes[,2]=="Y")
genes[xidx, 2] <- 23
genes[yidx, 2] <- 24
genes[,2] <- sapply(genes[,2],as.integer)
genes <- genes[order(genes[,3]),]
genes <- genes[order(genes[,2]),]
colnames(genes) <- c("GeneSymbol","Chr","Start","End")
genes_GR <- makeGRangesFromDataFrame(genes,keep.extra.columns = TRUE)

##################################
## Recurrent CNV identification ## 
##################################

for(tumor in tumorList){

    load(paste0(tumor,"_Genome_Wide_SNP_6.rda"))

    # Prepare CNV matrix
    cnvMatrix <- dataAssay
    # Add label (0 for loss, 1 for gain)
    cnvMatrix <- cbind(cnvMatrix,Label=NA)
    cnvMatrix[cnvMatrix[,"Segment_Mean"] < -0.3,"Label"] <- 0
    cnvMatrix[cnvMatrix[,"Segment_Mean"] > 0.3,"Label"] <- 1
    cnvMatrix <- cnvMatrix[!is.na(cnvMatrix$Label),]
    # Remove "Segment_Mean" and change col.names
    cnvMatrix <- cnvMatrix[,-6]
    colnames(cnvMatrix) <- c("Sample.Name", "Chromosome", "Start", "End", "Num.of.Markers", "Aberration")
    # Substitute Chromosomes "X" and "Y" with "23" and "24"
    xidx <- which(cnvMatrix$Chromosome=="X")
    yidx <- which(cnvMatrix$Chromosome=="Y")
    cnvMatrix[xidx,"Chromosome"] <- 23
    cnvMatrix[yidx,"Chromosome"] <- 24
    cnvMatrix$Chromosome <- sapply(cnvMatrix$Chromosome,as.integer)

    # Recurrent CNV identification with GAIA

    # Retrieve probes meta file from broadinstitute website
    # Recurrent CNV identification with GAIA
    gdac.root <- "ftp://ftp.broadinstitute.org/pub/GISTIC2.0/hg19_support/"
    message("Retrieve probes meta file from broadinstitute website")
    file <- "genome.info.6.0_hg19.na31_minus_frequent_nan_probes_sorted_2.1.txt"
    if(!file.exists(file)){
        downloader::download(paste0(gdac.root,file),file)
    }
    markersMatrix <-  read.delim("genome.info.6.0_hg19.na31_minus_frequent_nan_probes_sorted_2.1.txt",as.is=TRUE, header=FALSE)
    colnames(markersMatrix) <- c("Probe.Name", "Chromosome", "Start")
    unique(markersMatrix$Chromosome)
    xidx <- which(markersMatrix$Chromosome=="X")
    yidx <- which(markersMatrix$Chromosome=="Y")
    markersMatrix[xidx,"Chromosome"] <- 23
    markersMatrix[yidx,"Chromosome"] <- 24
    markersMatrix$Chromosome <- sapply(markersMatrix$Chromosome,as.integer)
    markerID <- apply(markersMatrix,1,function(x) paste0(x[2],":",x[3]))
    markersMatrix <- markersMatrix[-which(duplicated(markerID)),]
    # Filter markersMatrix for common CNV
    markerID <- apply(markersMatrix,1,function(x) paste0(x[2],":",x[3]))
    commonCNV <- read.delim(paste0(gdac.root,"CNV.hg19.bypos.111213.txt"), as.is=TRUE)
    commonCNV[,2] <- sapply(commonCNV[,2], as.integer)
    commonCNV[,3] <- sapply(commonCNV[,3], as.integer)
    commonID <- apply(commonCNV,1,function(x) paste0(x[2],":",x[3]))
    markersMatrix_fil <- markersMatrix[!markerID %in% commonID,]

    markers_obj <- load_markers(markersMatrix_fil)

    message("Gene information loaded")
    cnv_obj <- load_cnv(cnvMatrix, markers_obj, length(selected))

    # For speed process we will evaluate only chromessome 14 up to 18, 
    # use chromosomes = -1 to consider all chromossomes
    results <- runGAIA(cnv_obj, markers_obj, output_file_name=paste0("GAIA_",tumor,"_",PlatformTumor,"_flt.txt"),
                       aberrations = -1,  chromosomes = c(14:18), num_iterations = 10, threshold = 0.25)

    # Set q-value threshold
    threshold <- 0.001

    # Plot the results
    RecCNV <- t(apply(results,1,as.numeric))
    colnames(RecCNV) <- colnames(results)
    RecCNV <- cbind(RecCNV, score=0)
    minval <- format(min(RecCNV[RecCNV[,"q-value"]!=0,"q-value"]),scientific=FALSE)
    minval <- substring(minval,1, nchar(minval)-1)
    RecCNV[RecCNV[,"q-value"]==0,"q-value"] <- as.numeric(minval)
    RecCNV[,"score"] <- sapply(RecCNV[,"q-value"],function(x) -log10(as.numeric(x)))
    RecCNV[RecCNV[,"q-value"]==as.numeric(minval),]

    gaiaCNVplot(RecCNV,tumor,threshold)

    save(results, RecCNV, threshold, file = paste0(tumor,"_CNV_results.rda"))

    #--------------------  Section 3.3: Gene annotation of recurrent CNV --------------------------
    load(paste0(tumor,"_CNV_results.rda"))

    sCNV <- RecCNV[RecCNV[,"q-value"]<=threshold,c(1:4,6)]
    sCNV <- sCNV[order(sCNV[,3]),]
    sCNV <- sCNV[order(sCNV[,1]),]
    colnames(sCNV) <- c("Chr","Aberration","Start","End","q-value")
    sCNV_GR <- makeGRangesFromDataFrame(sCNV,keep.extra.columns = TRUE)

    hits <- findOverlaps(genes_GR, sCNV_GR, type="within")
    sCNV_ann <- cbind(sCNV[subjectHits(hits),],genes[queryHits(hits),])
    AberrantRegion <- paste0(sCNV_ann[,1],":",sCNV_ann[,3],"-",sCNV_ann[,4])
    GeneRegion <- paste0(sCNV_ann[,7],":",sCNV_ann[,8],"-",sCNV_ann[,9])
    AmpDel_genes <- cbind(sCNV_ann[,c(6,2,5)],AberrantRegion,GeneRegion)
    AmpDel_genes[AmpDel_genes[,2]==0,2] <- "Del"
    AmpDel_genes[AmpDel_genes[,2]==1,2] <- "Amp"
    rownames(AmpDel_genes) <- NULL

    save(RecCNV, AmpDel_genes, file = paste0(tumor,"_CNV_results.rda"))
}
```

Recurrent amplifications and deletions were identified for LGG, and represented in chromosomal overview plots by a statistical score (*$-log_{10}$ corrected p-value* for amplifications and *$log_{10}$ corrected p-value* for deletions). Genomic regions identified as significantly altered in copy number (*corrected p-value* < $10^{-3}$) were then annotated to report amplified and deleted genes potentially related with cancer.


### Gene annotation of recurrent CNV
The aberrant recurrent genomic regions in cancer, as identified by GAIA,
have to be annotated to verify which genes are significantly amplified or deleted.
Using biomaRt we retrieved the genomic ranges of all human genes and we compared
them with significant aberrant regions to select full length genes. An example of
the result is shown in table \ref{tab::tab1}.

```{r results='asis', echo=TRUE, message=FALSE,warning=FALSE}
##############################
## Recurrent CNV annotation ## 
##############################
# Get gene information
mart <- useMart(biomart="ensembl", dataset="hsapiens_gene_ensembl")
genes <- getBM(attributes = c("hgnc_symbol", "chromosome_name","start_position","end_position"), mart=mart)
genes <- genes[genes[,1]!="" & genes[,2]%in%c(1:22,"X","Y"),]
xidx <- which(genes[,2]=="X")
yidx <- which(genes[,2]=="Y")
genes[xidx, 2] <- 23
genes[yidx, 2] <- 24
genes[,2] <- sapply(genes[,2],as.integer)
genes <- genes[order(genes[,3]),]
genes <- genes[order(genes[,2]),]
colnames(genes) <- c("GeneSymbol","Chr","Start","End")
genes_GR <- makeGRangesFromDataFrame(genes,keep.extra.columns = TRUE)

for(tumor in tumorList){
	load(paste0(tumor,"_CNV_results.rda"))

    sCNV <- RecCNV[RecCNV[,"q-value"]<=threshold,c(1:4,6)]
    sCNV <- sCNV[order(sCNV[,3]),]
    sCNV <- sCNV[order(sCNV[,1]),]
    colnames(sCNV) <- c("Chr","Aberration","Start","End","q-value")
    sCNV_GR <- makeGRangesFromDataFrame(sCNV,keep.extra.columns = TRUE)

    hits <- findOverlaps(genes_GR, sCNV_GR, type="within")
    sCNV_ann <- cbind(sCNV[subjectHits(hits),],genes[queryHits(hits),])
    AberrantRegion <- paste0(sCNV_ann[,1],":",sCNV_ann[,3],"-",sCNV_ann[,4])
    GeneRegion <- paste0(sCNV_ann[,7],":",sCNV_ann[,8],"-",sCNV_ann[,9])
    AmpDel_genes <- cbind(sCNV_ann[,c(6,2,5)],AberrantRegion,GeneRegion)
    AmpDel_genes[AmpDel_genes[,2]==0,2] <- "Del"
    AmpDel_genes[AmpDel_genes[,2]==1,2] <- "Amp"
    rownames(AmpDel_genes) <- NULL

    save(RecCNV, AmpDel_genes, file = paste0(tumor,"_CNV_results.rda"))
}
```


### Visualizing multiple genomic alteration events
In order to visualize multiple genomic alteration events we recommend using OncoPrint plot which is provided by bioconductor package  [complexHeatmap](http://bioconductor.org/packages/ComplexHeatmap/)  [@ComplexHeatmap]. The listing below shows how to download mutation data using
 `TCGAquery_maf` (line 4), then we filtered the genes to obtain genes with mutations found among glioma
specific pathways (lines 6 - 12).  The following steps prepared the data into a matrix to fit
 `oncoPrint` function.
We defined SNPs as blue, insertions as green and deletions as red.
The upper barplot indicates the number of genetic mutation per patient,
while the right barplot shows the number of genetic mutations per gene.
Also, it is possible to add annotations to rows or columns.
In the columns case, if an insertion is made at the top, will remove the barplot.
The final result for adding the annotation to the bottom is highlighted in the figure.

```{#numCode .R .numberLines}
library(ComplexHeatmap) # Version 1.10.2
library(TCGAbiolinks)

LGGmut <- TCGAquery_maf(tumor = "LGG",archive.name="LGG.IlluminaGA_DNASeq_curated.Level_2.1.4.0")
GBMmut <- TCGAquery_maf(tumor = "GBM", archive.name = "ucsc.edu_GBM.IlluminaGA_DNASeq_automated.Level_2.1.1.0")
mut <- plyr::rbind.fill(LGGmut,GBMmut)

# Filtering mutations in gliomas
EA_pathways <- TCGAbiolinks:::listEA_pathways
Glioma_pathways <- EA_pathways[grep("glioma", tolower(EA_pathways$Pathway)),]
Glioma_signaling <- Glioma_pathways[Glioma_pathways$Pathway == "Glioma Signaling",]
Glioma_signaling_genes <- unlist(strsplit(as.character(Glioma_signaling$Molecules),","))

# For time reasons we will use only 10 genes
mut <- mut[mut$Hugo_Symbol %in% Glioma_signaling_genes[1:10],]

samples <- unique(mut$Tumor_Sample_Barcode)
genes <- unique(mut$Hugo_Symbol)
mat <- matrix(0,length(genes),length(samples))
colnames(mat) <- samples
rownames(mat) <- genes

pb <- txtProgressBar(min = 0, max = nrow(mat), style = 3)

for (i in 1:nrow(mat)) {
    curGene <- rownames(mat)[i]
    setTxtProgressBar(pb, i)
    for (j in 1:ncol(mat)) {
        curSample <- colnames(mat)[j]

        if (length(intersect(mut$Tumor_Sample_Barcode, curSample))==1){
            mat1 <- mut[mut$Tumor_Sample_Barcode == curSample,]
            if (length(intersect(mat1$Hugo_Symbol, curGene))==1){
                mat3 <- mat1[mat1$Hugo_Symbol == curGene,]
                mat[curGene,curSample]<- as.character(mat3$Variant_Type)[1]
            }
        }
    }
}
close(pb)

mat[mat==0] <- ""
colnames(mat) <- substr(colnames(mat),1,12)

mat[is.na(mat)] = ""
#mat = t(as.matrix(mat))
mat[1:3, 1:3]

alter_fun = list(
    background = function(x, y, w, h) {
        grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = "#CCCCCC", col = NA))
    },
    SNP = function(x, y, w, h) {
        grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = "blue", col = NA))
    },
    DEL = function(x, y, w, h) {
        grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = "red", col = NA))
    },
    INS = function(x, y, w, h) {
        grid.rect(x, y, w-unit(0.5, "mm"), h*0.33, gp = gpar(fill = "#008000", col = NA))
    }
)

col = c("INS" = "#008000", "DEL" = "red", "SNP" = "blue")

clin.gbm <- TCGAquery_clinic("gbm", "clinical_patient")
clin.lgg <- TCGAquery_clinic("lgg", "clinical_patient")
clinical <- plyr::rbind.fill(clin.lgg,clin.gbm)
annotation <- clinical[match(colnames(mat),clinical$bcr_patient_barcode),c("disease","radiation_therapy")]
annotation <- HeatmapAnnotation(annotation_height = rep(unit(0.3, "cm"),ncol(annotation)),
                                df = annotation,
                                col = list(disease = c("LGG"="green", "GBM"="orange"),
                                           radiation_therapy = c("YES"="blue","NO"="red",
                                                                 "[Unknown]"="yellow","[Not Available]"="grey")),
                                annotation_legend_param = list(title_gp = gpar(fontsize = 16, fontface = "bold"),
                                                               labels_gp = gpar(fontsize = 16), # size labels
                                                               grid_height = unit(8, "mm")))

pdf("LGG_GBM_oncoprint.pdf",width = 20,height = 20)
p <- oncoPrint(mat, get_type = function(x) strsplit(x, ";")[[1]],
          remove_empty_columns = FALSE,
          column_order = NULL, # Do not sort the columns
          alter_fun = alter_fun, col = col,
          row_names_gp = gpar(fontsize = 16),  # set size for row names
          pct_gp = gpar(fontsize = 16), # set size for percentage labels
          axis_gp = gpar(fontsize = 16),# size of axis
          column_title = "OncoPrint for TCGA LGG, genes in Glioma signaling",
          column_title_gp = gpar(fontsize = 22),
          pct_digits = 2,
          row_barplot_width = unit(4, "cm"), #size barplot
          bottom_annotation = annotation,
          heatmap_legend_param = list(title = "Mutations", at = c("DEL", "INS", "SNP"),
                                      labels = c("DEL", "INS", "SNP"),
                                      title_gp = gpar(fontsize = 16, fontface = "bold"),
                                      labels_gp = gpar(fontsize = 16), # size labels
                                      grid_height = unit(8, "mm")
          )
)
draw(p, annotation_legend_side =  "bottom")
dev.off()
```

![Oncoprint for LGG samples. Blue defines SNP, green defines insertions and red defines deletions.
  The upper barplot shows the number of these genetic mutation for each patient,
  while the right barplot shows the number of genetic mutations for each gene. The bottom bar shows the group of each sample.\label{oncoprint}](LGG_GBM_oncoprint.png)


**Overview of genomic alterations by circos plot**

Genomic alterations in cancer, including CNV and mutations, can be represented in an effective overview plot named circos.
 We used [circlize](https://cran.r-project.org/web/packages/circlize/index.html) CRAN package to represent significant CNV (resulting from GAIA analysis) and recurrent mutations
 (selecting curated genetic variations retrieved from TCGA that are identified in at least two tumor samples) in LGG.
 Circos plot can illustrate molecular alterations genome-wide or only in one or more selected chromosomes.
```{r results='asis', echo=TRUE, message=FALSE,warning=FALSE}

###############################################
## Genomic aberration overview - Circos plot ## 
###############################################

# Retrieve curated mutations for selected tumor (e.g. "LGG") 
library(TCGAbiolinks)
mut <- TCGAquery_maf(tumor = "LGG",archive.name="LGG.IlluminaGA_DNASeq_curated.Level_2.1.4.0")
# Select only potentially damaging mutations
mut <- mut[mut$Variant_Classification %in% c("Missense_Mutation","Nonsense_Mutation","Nonstop_Mutation","Frame_Shift_Del","Frame_Shift_Ins"),]
# Select recurrent mutations (identified in at least two samples)
mut.id <- paste0(mut$Chromosome,":",mut$Start_position,"-",mut$End_position,"|",mut$Reference_Allele,"/",mut$Tumor_Seq_Allele2)
mut <- cbind(mut.id, mut)
numSamples <- table(mut.id)
s.mut <- names(which(numSamples>=2))
# Prepare selected mutations data for circos plot
s.mut <- mut[mut$mut.id %in% s.mut,]
s.mut <- s.mut[,c("Chromosome","Start_position","End_position","Variant_Classification","Hugo_Symbol")]
s.mut <- unique(s.mut)
Chromosome <- sapply(s.mut[,1],function(x) paste0("chr",x))
s.mut <- cbind(Chromosome,s.mut[,-1])
s.mut[,1] <- as.character(s.mut[,1])
s.mut[,4] <- as.character(s.mut[,4])
s.mut[,5] <- as.character(s.mut[,5])
typeNames <- unique(s.mut[,4])
type <- c(4:1)
names(type) <- typeNames[1:4]
Type <- type[s.mut[,4]]
s.mut <- cbind(s.mut,Type)
s.mut <- s.mut[,c(1:3,6,4,5)]

# Load recurrent CNV data for selected tumor (e.g. "LGG")
load("LGG_CNV_results.rda")
# Prepare selected sample CNV data for circos plot
s.cnv <- as.data.frame(RecCNV[RecCNV[,"q-value"]<=threshold,c(1:4,6)])
s.cnv <- s.cnv[,c(1,3,4,2)]
xidx <- which(s.cnv$Chromosome==23)
yidx <- which(s.cnv$Chromosome==24)
s.cnv[xidx,"Chromosome"] <- "X"
s.cnv[yidx,"Chromosome"] <- "Y"
Chromosome <- sapply(s.cnv[,1],function(x) paste0("chr",x))
s.cnv <- cbind(Chromosome, s.cnv[,-1])
s.cnv[,1] <- as.character(s.cnv[,1])
s.cnv[,4] <- as.character(s.cnv[,4])
s.cnv <- cbind(s.cnv,CNV=1)
colnames(s.cnv) <- c("Chromosome","Start_position","End_position","Aberration_Kind","CNV")

# Draw genomic circos plot
library(circlize)
par(mar=c(1,1,1,1), cex=1)
circos.initializeWithIdeogram()
# Add CNV results
colors <- c("forestgreen","firebrick")
names(colors)  <- c(0,1)
circos.genomicTrackPlotRegion(s.cnv,  ylim = c(0,1.2),
                              panel.fun = function(region, value, ...) {
                                  circos.genomicRect(region, value, ytop.column = 2, ybottom = 0,
                                                     col = colors[value[[1]]],
                                                     border="white")
                                  cell.xlim = get.cell.meta.data("cell.xlim")
                                  circos.lines(cell.xlim, c(0, 0), lty = 2, col = "#00000040")
                              })
# Add mutation results
colors <- c("blue","green","red","gold")
names(colors)  <- typeNames[1:4]
circos.genomicTrackPlotRegion(s.mut, ylim = c(1.2,4.2),
                              panel.fun = function(region, value, ...) {
                                  circos.genomicPoints(region, value, cex = 0.8, pch = 16, col = colors[value[[2]]], ...)
                              })

circos.clear()

legend(-0.2, 0.2, bty="n", y.intersp=1, c("Amp","Del"), pch=15, col=c("firebrick","forestgreen"), title="CNVs", text.font=2, cex=0.7, title.adj=0)
legend(-0.2, 0, bty="n", y.intersp=1, names(colors), pch=16, col=colors, title="Mutations", text.font=2, cex=0.7, title.adj=0)
```

```{r results='asis', echo=TRUE, message=FALSE,warning=FALSE}
par(mar=c(1,1,1,1),cex=1.5)
circos.par("start.degree" = 90, canvas.xlim = c(0, 1), canvas.ylim = c(0, 1),
           gap.degree = 270, cell.padding = c(0, 0, 0, 0), track.margin = c(0.005, 0.005))
circos.initializeWithIdeogram(chromosome.index = "chr17")
circos.par(cell.padding = c(0, 0, 0, 0))
# Add CNV results
colors <- c("forestgreen","firebrick")
names(colors)  <- c(0,1)
circos.genomicTrackPlotRegion(s.cnv,  ylim = c(0,1.2),
                              panel.fun = function(region, value, ...) {
                                  circos.genomicRect(region, value, ytop.column = 2, ybottom = 0,
                                                     col = colors[value[[1]]],
                                                     border="white")
                                  cell.xlim = get.cell.meta.data("cell.xlim")
                                  circos.lines(cell.xlim, c(0, 0), lty = 2, col = "#00000040")
                              })

# Add mutation results representing single genes
genes.mut <- paste0(s.mut$Hugo_Symbol,"-",s.mut$Type)
s.mutt <- cbind(s.mut,genes.mut)
n.mut <- table(genes.mut)
idx <- !duplicated(s.mutt$genes.mut)
s.mutt <- s.mutt[idx,]
s.mutt <- cbind(s.mutt,num=n.mut[s.mutt$genes.mut])
genes.num <- paste0(s.mutt$Hugo_Symbol," (",s.mutt$num,")")
s.mutt <- cbind(s.mutt[,-c(6:8)],genes.num)
s.mutt[,6] <- as.character(s.mutt[,6])
s.mutt[,4] <- s.mutt[,4]/2

colors <- c("blue","green","red","gold")
names(colors)  <- typeNames[1:4]
circos.genomicTrackPlotRegion(s.mutt, ylim = c(0.3,2.2), track.height = 0.05,
                              panel.fun = function(region, value, ...) {
                                  circos.genomicPoints(region, value, cex = 0.8, pch = 16, col = colors[value[[2]]], ...)
                              })

circos.genomicTrackPlotRegion(s.mutt, ylim = c(0, 1), track.height = 0.1, bg.border = NA)
i_track = get.cell.meta.data("track.index")

circos.genomicTrackPlotRegion(s.mutt, ylim = c(0,1),
                              panel.fun = function(region, value, ...) {
                                  circos.genomicText(region, value,
                                                     y = 1,
                                                     labels.column = 3,
                                                     col = colors[value[[2]]],
                                                     facing = "clockwise", adj = c(1, 0.5),
                                                     posTransform = posTransform.text, cex = 1.5, niceFacing = T)
                              }, track.height = 0.1, bg.border = NA)

circos.genomicPosTransformLines(s.mutt,
                                posTransform = function(region, value)
                                    posTransform.text(region,
                                                      y = 1,
                                                      labels = value[[3]],
                                                      cex = 0.8, track.index = i_track+1),
                                direction = "inside", track.index = i_track)

circos.clear()

legend(0.4, 0.2, bty="n", y.intersp=1, c("Amp","Del"), pch=15, col=c("firebrick","forestgreen"),
       title="CNVs", text.font=3, cex=0.7, title.adj=0)
legend(0, 0.2, bty="n", y.intersp=1, names(colors), pch=16, col=colors,
       title="Mutations", text.font=3, cex=0.7, title.adj=0)
```


## Transcriptomic analysis




### Pre-Processing Data

The  data used for following transcriptomic analysis were downloaded using TCGAbiolinks.
We downloaded 10 primary solid tumor (TP) samples that has both DNA methylation and gene expression data 
(this number of samples were used to make this workflow faster) then
prepared it in two separate rse object (RangedSummarizedExperiment) saving them as an
R object with a filename including both the name of the cancer and the name of the plaftorm used
for gene expression data.

```{#numCode .R .numberLines}
library(TCGAbiolinks)
library(stringr)

# defining common parameters
tumorList <- c("LGG","GBM")
PlatformTumor <- "IlluminaHiSeq_RNASeqV2"
dataType <- "rsem.genes.results"

# Get primary solid tumor samples with both DNA methyation and gene expression
matched_met_exp <- function(tumor, n = NULL){
    # get primary solid tumor samples: DNA methylation
    met450k <- TCGAquery(tumor = tumor,"HumanMethylation450", level = 3)
    met450k.tp <- TCGAquery_SampleTypes(unique(unlist(stringr::str_split(met450k$barcode,","))),c("TP"))

    # get primary solid tumor samples: RNAseq
    rnaseq <- TCGAquery(tumor = tumor,c("IlluminaHiSeq_RNASeqV2"),level = 3)
    rnaseq.tp <- TCGAquery_SampleTypes(unique(unlist(stringr::str_split(rnaseq$barcode,","))),c("TP"))

    # Get patients with samples in both platforms
    patients <- unique(substr(rnaseq.tp,1,15)[substr(rnaseq.tp,1,12) %in% substr(met450k.tp,1,12)] )
    if(!is.null(n)) patients <- patients[1:n] # get only n samples
    return(patients)
}
lgg.samples <- matched_met_exp("LGG", n = 10)
gbm.samples <- matched_met_exp("GBM", n = 10)
samples <- c(lgg.samples,gbm.samples)

for(tumor in tumorList){
	pathCancer <- paste0("data",tumor)
	datQuery <- TCGAquery(tumor = tumor, platform = PlatformTumor, level = "3")

  TCGAdownload(data = datQuery, path = pathCancer, type = dataType, samples = c(samples))
  dataAssy <- TCGAprepare(query = datQuery, dir = pathCancer, type = dataType,
                          save = TRUE, summarizedExperiment = TRUE,
                          samples = c(samples),
                          filename = paste0(tumor,"_",PlatformTumor,".rda"))
}
```
To pre-process the data, first, we searched for possible outliers using the `TCGAanalyze_Preprocessing`
function, which performs an Array Array Intensity correlation AAIC (lines 14-17 and 26-29 of listing below).
In this way we defined a square symmetric matrix of pearson correlation among all samples in each cancer type (LGG or GBM).
This matrix found 0 samples with low correlation (cor.cut = 0.6)
that can be identified as possible outliers.

Second, using the `TCGAanalyze_Normalization` function,
which encompasses the functions of the [EDASeq](http://bioconductor.org/packages/EDASeq/) package,
we normalized mRNA transcripts.

This function implements Within-lane normalization procedures to adjust for GC-content
effect (or other gene-level effects) on read counts: loess robust local regression,
global-scaling, and full-quantile normalization [@risso2011gc] and
between-lane normalization procedures to adjust for distributional
differences between lanes (e.g., sequencing depth): global-scaling and full-quantile normalization [@bullard2010evaluation].

```{#numCode .R .numberLines}
library(TCGAbiolinks)

# loading LGG and GBM rse data

load("LGG_IlluminaHiSeq_RNASeqV2.rda")
tumor <-  "LGG"
pathCancer <- paste0("data",tumor)
PlatformTumor <- "IlluminaHiSeq_RNASeqV2"

dataClin_LGG <- TCGAquery_clinic(tumor = "LGG",
                             clinical_data_type = "clinical_patient")


dataPrep_LGG <- TCGAanalyze_Preprocessing(object = rse,
                                      cor.cut = 0.6, 
                                      filename = "LGG_IlluminaHiSeq_RNASeqV2.png")

load("GBM_IlluminaHiSeq_RNASeqV2.rda")
tumor <-  "GBM"
pathCancer <- paste0("data",tumor)
PlatformTumor <- "IlluminaHiSeq_RNASeqV2"

dataClin_GBM <- TCGAquery_clinic(tumor = "GBM",
                                 clinical_data_type = "clinical_patient")

dataPrep_GBM <- TCGAanalyze_Preprocessing(object = rse,
                                          cor.cut = 0.6,
                                          filename = "GBM_IlluminaHiSeq_RNASeqV2.png")

dataNorm <- TCGAanalyze_Normalization(tabDF = cbind(dataPrep_LGG, dataPrep_GBM),
                                      geneInfo = geneInfo,
                                      method = "gcContent") #18323   672

dataFilt <- TCGAanalyze_Filtering(tabDF = dataNorm,
                                  method = "quantile",
                                  qnt.cut =  0.25)  # 13742   672

save(dataFilt, file = paste0("LGG_GBM_Norm_",PlatformTumor,".rda"))

dataFiltLGG <- subset(dataFilt, select = substr(colnames(dataFilt),1,12) %in% dataClin_LGG$bcr_patient_barcode)
dataFiltGBM <- subset(dataFilt, select = substr(colnames(dataFilt),1,12) %in% dataClin_GBM$bcr_patient_barcode)

dataDEGs <- TCGAanalyze_DEA(mat1 = dataFiltLGG,
                            mat2 = dataFiltGBM,
                            Cond1type = "LGG",
                            Cond2type = "GBM",
                            fdr.cut = 0.01 ,
                            logFC.cut = 1,
                            method = "glmLRT")
```

```{r results='asis', echo=TRUE, message=FALSE,warning=FALSE}
# Number of differentially expressed genes (DEG)
nrow(dataDEGs)

# number of LGG samples
length(lgg.samples)

# number of LGG samples
length(gbm.samples)
```


### EA: enrichment analysis
In order to understand the underlying biological process from DEGs we performed an
enrichment analysis using `TCGAanalyze_EA_complete` function.

```{#numCode .R .numberLines}
ansEA <- TCGAanalyze_EAcomplete(TFname="DEA genes LGG Vs GBM", RegulonList = rownames(dataDEGs))

TCGAvisualize_EAbarplot(tf = rownames(ansEA$ResBP),
                        GOBPTab = ansEA$ResBP, GOCCTab = ansEA$ResCC,
                        GOMFTab = ansEA$ResMF, PathTab = ansEA$ResPat,
                        nRGTab = rownames(dataDEGs),
                        nBar = 20)
```

![\label{eabarplot} The plot shows canonical pathways significantly overrepresented (enriched)
by the DEGs (differentially expressed genes)  with the number of genes for the main categories of
three ontologies (GO:biological process, GO:cellular component, and GO:molecular function, respectively).
The most statistically significant canonical pathways identified in DEGs list are listed according
to their p value corrected FDR (-Log) (colored bars) and the ratio of list genes found in each
pathway over the total number of genes in that pathway (ratio, red line).](ea.png)

 `TCGAanalyze_EAbarplot` outputs a bar chart as shown in figure \ref{eabarplot}
 with the number of genes for the main categories of three ontologies (GO:biological process,
 GO:cellular component, and GO:molecular function.


The figure shows canonical pathways significantly overrepresented (enriched) by the DEGs.
The most statistically significant canonical pathways identified in DEGs list are listed according
to their p-value corrected FDR (-Log10) (colored bars) and the ratio of list genes found in each
pathway over the total number of genes in that pathway (ratio, red line).


### PEA: Pathways enrichment analysis

To verify if the genes found have a specific role in a pathway, the bioconducotor package
[pathview](http://bioconductor.org/packages/pathview/) [@luo2013pathview] can be used.
It can receive, for example, a named
vector of gene with the expression level,
the pathway.id which can be found in [KEGG database](http://www.genome.jp/kegg/pathway.html),
the species ('hsa' for Homo sapiens) and the limits for the gene expression.

```{#numCode .R .numberLines}
GenelistComplete <- rownames(assay(rse,1))

# DEGs TopTable
dataDEGsFiltLevel <- TCGAanalyze_LevelTab(dataDEGs,"LGG","GBM",
                                          dataFilt[,colnames(dataFiltLGG)],
                                          dataFilt[,colnames(dataFiltGBM)])

dataDEGsFiltLevel$GeneID <- 0

# Converting Gene symbol to geneID
library(clusterProfiler)
eg = as.data.frame(bitr(dataDEGsFiltLevel$mRNA,
                        fromType="SYMBOL",
                        toType="ENTREZID",
                        annoDb="org.Hs.eg.db"))
eg <- eg[!duplicated(eg$SYMBOL),]

dataDEGsFiltLevel <- dataDEGsFiltLevel[dataDEGsFiltLevel$mRNA %in% eg$SYMBOL,]

dataDEGsFiltLevel <- dataDEGsFiltLevel[order(dataDEGsFiltLevel$mRNA,decreasing=FALSE),]
eg <- eg[order(eg$SYMBOL,decreasing=FALSE),]

# table(eg$SYMBOL == dataDEGsFiltLevel$mRNA) should be TRUE
all(eg$SYMBOL == dataDEGsFiltLevel$mRNA)
dataDEGsFiltLevel$GeneID <- eg$ENTREZID

dataDEGsFiltLevel_sub <- subset(dataDEGsFiltLevel, select = c("GeneID", "logFC"))
genelistDEGs <- as.numeric(dataDEGsFiltLevel_sub$logFC)
names(genelistDEGs) <- dataDEGsFiltLevel_sub$GeneID

require("pathview")
# pathway.id: hsa05214 is the glioma pathway
# limit: sets the limit for gene expression legend and color
hsa05214 <- pathview(gene.data  = genelistDEGs,
                     pathway.id = "hsa05214",
                     species    = "hsa",
                     limit      = list(gene=as.integer(max(abs(genelistDEGs)))))

```

![\label{gliomapathview} Pathways enrichment analysis : glioma pathway. Red defines genes that are up-regulated and green defines genes that are down-regulated.](hsa05214.pathview.png)

The red genes are up-regulated and the
green genes are down-regulated in the LGG samples compared to GBM.

### Inference of gene regulatory networks

Starting with the set of differentially expressed genes, we infer gene regulatory networks using the following state-of-the art inference algorithms: ARACNE [@margolin2006aracne], CLR [@faith2007large], MRNET [@meyer2007information] and C3NET [@altay2010inferring]. These methods are based on mutual inference and use different heuristics to infer the edges in the network. These methods have been made available via Bioconductor/CRAN packages [MINET](http://bioconductor.org/packages/minet/)[@Meyer2008] and 
[c3net](https://cran.r-project.org/web/packages/c3net/index.html), [@altay2010inferring] respectively).

Many gene regulatory interactions have been experimentally validated and published.
These 'known' interactions can be accessed using different tools and databases such as
BioGrid [@Stark01012006] or GeneMANIA [@montojo2010genemania].
However, this knowledge is far from complete and in most cases only contains a small
subset of the real interactome. The quality assessment of the inferred networks can be carried out by
comparing the inferred interactions to those that have been validated. This comparison results in a
confusion matrix as presented in Table~\ref{table::confusion_matrix}.

```{r table3, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "  
|              | validated | not validated/non-existing |
|--------------|:---------:|:--------------------------:|
| inferred     |     TP    |             FP             |
| not inferred |     FN    |             TN             |
"
cat(tabl) 
```

Different quality measures can then be computed such as the false positive rate

$$ 
fpr=\frac{FP}{FP+TN},
$$ 
the true positive rate (also called recall)
$$ 
tpr=\frac{TP}{TP+FN}
$$ 
and the precision
$$ 
p=\frac{TP}{TP+FP}.
$$ 
The performance of an algorithm can then be summarized using ROC (false positive rate versus true positive rate) or PR (precision versus recall) curves.

A weakness of this type of comparison is that an edge that is not present in the set of known interactions can either mean that an experimental validation has been tried and did not show any regulatory mechanism or (more likely) has not yet been attempted.

In the following, we ran the nce on the differentially expressed genes identified in Section "Transcriptomic analysis"

**Retrieving known interactions**

We obtained a set of known interactions from the BioGrid database.

```{#numCode .R .numberLines}
get.adjacency.biogrid <- function(tmp.biogrid, names.genes = NULL){

	if(is.null(names.genes)){
		names.genes <- sort(union(unique(tmp.biogrid[,"Official.Symbol.Interactor.A"]), 
		unique(tmp.biogrid[,"Official.Symbol.Interactor.B"])))
		ind <- seq(1,nrow(tmp.biogrid))
	}else{
		ind.A <- which(tmp.biogrid[,"Official.Symbol.Interactor.A"]%in%names.genes)
		ind.B <- which(tmp.biogrid[,"Official.Symbol.Interactor.B"]%in%names.genes)

		ind <- intersect(ind.A, ind.B)
	}

	mat.biogrid <- matrix(0, nrow=length(names.genes), ncol=length(names.genes), 
	                      dimnames=list(names.genes, names.genes))

	for(i in ind){
		mat.biogrid[tmp.biogrid[i,"Official.Symbol.Interactor.A"], 
		            tmp.biogrid[i,"Official.Symbol.Interactor.B"]] <- mat.biogrid[
		            tmp.biogrid[i,"Official.Symbol.Interactor.B"],
		            tmp.biogrid[i,"Official.Symbol.Interactor.A"]] <- 1
	}
	diag(mat.biogrid) <- 0

	return(mat.biogrid)
}
```

**Using differentially expressed genes from TCGAbiolinks workflow**

We start this analysis by inferring four gene regulatory networks for the GBM data set
and for the LGG data set using the DEA gene set.

```{#numCode .R .numberLines}
### plot details (colors & symbols)
mycols<-c('#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628')

### load network inference libraries
library(minet)
library(c3net)

### deferentially identified genes using TCGAbiolinks
names.genes.de <- rownames(dataDEGs)
names.genes.sb <- unique(starburst[,"Gene_Symbol"])

### read biogrid info
library(downloader)
file <- "http://thebiogrid.org/downloads/archives/Release%20Archive/BIOGRID-3.4.137/BIOGRID-ALL-3.4.137.tab2.zip"
download(file,basename(file))
unzip(basename(file),junkpaths =T)
tmp.biogrid <- read.csv(gsub("zip","txt",basename(file)), header=TRUE, sep="\t", stringsAsFactors=FALSE)
net.biogrid.de <- get.adjacency.biogrid(tmp.biogrid, names.genes.de)

for (tumor in c("LGG", "GBM")) {

    if(tumor == "GBM"){
        mydata <- dataFiltGBM[names.genes.de, ]
    }else if(tumor == "LGG"){
        mydata <- dataFiltLGG[names.genes.de, ]
    }
    ### infer networks
    net.aracne <- minet(t(mydata), method = "aracne")
    net.mrnet <- minet(t(mydata))
    net.clr <- minet(t(mydata), method = "clr")
    net.c3net <- c3net(mydata)

    ### validate compared to biogrid network
    tmp.val <- list(validate(net.aracne, net.biogrid.de), validate(net.mrnet, net.biogrid.de),
                    validate(net.clr, net.biogrid.de), validate(net.c3net, net.biogrid.de))

    ### plot roc and compute auc for the different networks
    dev1 <- show.roc(tmp.val[[1]],cex=0.3,col=mycols[1],type="l")
    res.auc <- auc.roc(tmp.val[[1]])
    for(count in 2:length(tmp.val)){
        show.roc(tmp.val[[count]],device=dev1,cex=0.3,col=mycols[count],type="l")
        res.auc <- c(res.auc, auc.roc(tmp.val[[count]]))
    }

    legend("bottomright", legend=paste(c("aracne","mrnet","clr","c3net"), signif(res.auc,4), sep=": "),
           col=mycols[1:length(tmp.val)],lty=1, bty="n" )
    dev.copy2pdf(width=8,height=8,device = dev1, file = paste0("roc_biogrid_",tumor,".pdf"))
    save(net.aracne, net.mrnet, net.clr, net.c3net, file=paste0("nets_",tumor,".RData"))
}
```

![ROC with corresponding AUC for inferred GBM networks compared to
    BioGrid interactions\label{fig::roc_GBM}](roc_biogrid_GBM.png)
![ROC with corresponding AUC for inferred LGG networks compared to
    BioGrid interactions\label{fig::roc_LGG}](roc_biogrid_LGG.png)


In Figure above , the obtained ROC curve and the corresponding area under curve (AUC) are presented. 
It can be observed that MRNET perform best when comparing the inferred network with known interactions from the BioGrid database.


## Epigenetic analysis

The DNA methylation is an important component in numerous cellular processes, such as embryonic development, genomic imprinting, X-chromosome inactivation, and preservation of chromosome stability [@phillips2008role] .

In mammals, DNA methylation is found sparsely but globally, distributed in definite CpG sequences throughout the entire genome. There is however an exception, the CpG islands (CGIs) which are short interspersed DNA sequences with are enriched for GC.
These CpG islands are normally found in sites of transcription initiation and their methylation can lead to gene silencing [@deaton2011cpg].

Thus, the investigation of the DNA methylation is crucial to understanding regulatory  gene  networks  in  cancer as the DNA methylation represses transcription [@robertson2005dna]. Therefore, the DMR (differentially Methylation Region) detection can help us investigate regulatory  gene  networks.

This section describes the analysis of DNA methylation using the bioconductor package [TCGAbiolinks](http://bioconductor.org/packages/TCGAbiolinks/) [@TCGAbiolinks]. For this analysis, DNA methylation data from the platform Infinium HumanMethylation450 for GBM and LGG data were obtained. We started by checking the mean DNA methylation of different groups of samples, then a DMR (Differentially methylated region) analysis is performed in which we search for regions that have possible biological significance, for example, regions that are methylated in one group and unmethylated in the other. After finding these regions, they can be visualized using heatmaps.

### Visualizing the mean DNA methylation of each patient

It should be highlighted that some pre-processing of the DNA methylation data was done. The DNA methylation data from the 450k platform has three types of probes cg (CpG loci) , ch (non-CpG loci) and rs (SNP assay). The last type of probe can be used for sample identification and tracking and should be excluded for differential methylation analysis according to the [ilumina manual](https://support.illumina.com/content/dam/illumina-support/documents/myillumina/90666eaa-0c66-48b4-8199-3be99b2b3ef9/genomestudio_methylation_v1.8_user_guide_11319130_b.pdf). Therefore, the rs probes were removed  (see listing below lines 22). Also,  probes in chromosomes X, Y were removed to eliminate potential artifacts originating from the presence of a different proportion of males and females [@marabita2013evaluation]. The last pre-processing steps were to selected only primary samples (see listing below lines 16) and probes with at least one NA value were removed (see listing below lines 19).

After this pre-processing step, using the function `TCGAvisualize_meanMethylation` provided we can take a look at the mean DNA methylation of each patient in each group. It receives as argument a summarizedExperiment object with the DNA methylation data, and the arguments groupCol and subgroupCol  which should be two columns from the sample information matrix of the summarizedExperiment object (accessed by the colData function) (see listing below lines 25-29).

```{#numCode .R .numberLines}
#----------------------------
# Obtaining DNA methylation
#----------------------------
library(TCGAbiolinks)
library(stringr)
# Samples
matched_met_exp <- function(tumor, n = NULL){
    # get primary solid tumor samples: DNA methylation
    met450k <- TCGAquery(tumor = tumor,"HumanMethylation450", level = 3)
    met450k.tp <- TCGAquery_SampleTypes(unique(unlist(stringr::str_split(met450k$barcode,","))),c("TP"))

    # get primary solid tumor samples: RNAseq
    rnaseq <- TCGAquery(tumor = tumor,c("IlluminaHiSeq_RNASeqV2"),level = 3)
    rnaseq.tp <- TCGAquery_SampleTypes(unique(unlist(stringr::str_split(rnaseq$barcode,","))),c("TP"))

    # Get patients with samples in both platforms
    patients <- unique(substr(rnaseq.tp,1,15)[substr(rnaseq.tp,1,12) %in% substr(met450k.tp,1,12)] )
    if(!is.null(n)) patients <- patients[1:n] # get only n samples
    return(patients)
}
lgg.samples <- matched_met_exp("LGG", n = 10)
gbm.samples <- matched_met_exp("GBM", n = 10)
samples <- c(lgg.samples,gbm.samples)

#-----------------------------------
# 1 - Methylation
# ----------------------------------
# For methylation it is quicker in this case to download the tar.gz file
# and get the samples we want instead of downloading files by files
query.met <- TCGAquery(tumor = c("GBM","LGG"), platform = "HumanMethylation450", level = 3, samples = samples)
TCGAdownload(query.met, samples = samples)
met <- TCGAprepare(query.met,dir = ".", save = FALSE,samples = samples)
met.elmer <- TCGAprepare_elmer(met, platform = "HumanMethylation450")

#----------------------------
# Mean methylation
#----------------------------
# Plot a barplot for the groups in the disease column in the
# summarizedExperiment object

# remove probes with NA (similar to na.omit)
met <- subset(met,subset = (rowSums(is.na(assay(met))) == 0))

# remove probes in chromossomes X, Y and NA
met <- subset(met,subset = !as.character(seqnames(met)) %in% c("chrNA","chrX","chrY"))

TCGAvisualize_meanMethylation(met,
                              groupCol = "disease",
                              group.legend  = "Groups",
                              filename = "mean_lgg_gbm.png",
                              print.pvalue = TRUE)
```

![](mean_lgg_gbm.png)

The figure above illustrates a mean DNA methylation plot for each sample in the GBM group (140 samples) and
a mean DNA methylation for each sample in the LGG group.  Genome-wide view of the data highlights a difference between the groups of tumors (p-value = $2.80x10^{-55}$).


### Searching for differentially methylated CpG sites

The next step is to define differentially methylated CpG sites between the two groups. This can be done using the `TCGAanalyze_DMR` function. The DNA methylation data (level 3) is presented in the form of beta-values that uses a scale ranging from 0.0 (probes completely unmethylated ) up to 1.0 (probes completely methylated).

To find these differentially methylated CpG sites, first, it calculates the difference between the mean DNA methylation (mean of the beta-values) of each group for each probe. Second, it test for differential expression between two groups using the wilcoxon test adjusting by the Benjamini-Hochberg method. Arguments of  `TCGAanalyze_DMR` was set to require a minimum absolute beta-values difference of 0.25 and an adjusted p-value of less than $10^{-40}$.

After these tests, a volcano plot (x-axis: difference of mean DNA methylation, y-axis: statistical significance) is created to help users identify the differentially methylated CpG sites and return the object with the results in the rowRanges.

```{#numCode .R .numberLines}
#-------  5.2 Searching for differentially methylated CpG sites     ----------
# Becareful! Depending on the number of probes and samples this function might take some days.
# But to accelerate the process we use only the chromosome 9
# This should take some minutes
met.chr9 <- subset(met,subset = as.character(seqnames(met)) %in% c("chr9"))

met.chr9 <- TCGAanalyze_DMR(met.chr9,
                       groupCol = "disease", # a column in the colData matrix
                       group1 = "GBM",       # a type of the the groupCol column
                       group2="LGG",         # a type of the the groupCol column
                       p.cut = 10^-2,
                       diffmean.cut = 0.25,
                       legend = "State",
                       plot.filename = "LGG_GBM_metvolcano.png",
                       cores = 1 # if set to 1 there will be a progress bar
)
```

The figure below shows the volcano plot produced by listing above.
This plot aids the user in selecting relevant thresholds, as we search for candidate biological DMRs.

![](LGG_GBM_metvolcano.png)



To visualize the level of DNA methylation of these probes across all samples, we use heatmaps that can be generate
by the bioconductor package [complexHeatmap](http://bioconductor.org/packages/ComplexHeatmap/) [@ComplexHeatmap]. 
To create a heatmap using the [complexHeatmap](http://bioconductor.org/packages/ComplexHeatmap/) package,
the user should provide at least one matrix with the DNA methylation levels.
Also, annotation layers can be added and placed at the bottom, top, left side and right side of the heatmap
to provide additional metadata description.
The listing above shows the code to produce the heatmap of a DNA methylation data.

```{#numCode .R .numberLines}
#--------------------------
# DNA Methylation heatmap
#-------------------------
library(ComplexHeatmap)

# get the probes that are Hypermethylated or Hypomethylated
# met is the same object of the section 'DNA methylation analysis'
sig.met <- met.chr9[values(met.chr9)$status.GBM.LGG %in% c("Hypermethylated","Hypomethylated"),]

# To speed up the example, let take a look on the first 100 probes
sig.met.100 <- sig.met[1:100,]

# top annotation, which sampples are LGG and GBM
# We will add clinical data as annotation of the samples
# we will sort the clinical data to have the same order of the DNA methylation matrix
clinical.order <- clinical[match(substr(colnames(sig.met.100),1,12),clinical$bcr_patient_barcode),]
ta = HeatmapAnnotation(df = clinical.order[,c("disease","gender","icd_o_3_histology","tumor_tissue_site")],
                       col = list(disease = c("LGG" = "grey", "GBM" = "black"),
                                  gender = c("MALE"="blue","FEMALE"="pink")))

# row annotation: add the status for LGG in relation to GBM
# For exmaple: status.gbm.lgg Hypomethyated means that the mean DNA methylation of
# probes for lgg are hypomethylated compared to GBM ones.
ra = rowAnnotation(df = values(sig.met.100)["status.GBM.LGG"],
                   col = list(status.GBM.LGG = c("Hypomethylated" = "orange",
                                                 "Hypermethylated" = "darkgreen")),
                   width = unit(1, "cm"))

heatmap  <- Heatmap(assay(sig.met.100),
                    name = "DNA methylation",
                    top_annotation = ta,
                    col = matlab::jet.colors(200),
                    show_row_names = F,
                    cluster_rows = T,
                    cluster_columns = F,
                    show_column_names = F,
                    column_title = "DNA Methylation") + ra
png("heatmap.png",width = 600, height = 400); draw(heatmap); dev.off()
```

![](heatmap.png)

### Motif analysis 
Motif discovery is the attempt to extract small sequence signals hidden within largely non-functional intergenic sequences. These sequence short nucleotide sequences (6-15 bp) might have a biological significance as it can be used to control the expression of genes. These sequences are called Regulatory motifs.
The bioconductor package [rGADEM](http://bioconductor.org/packages/rGADEM/) [@droit2015rgadem,@li2009gadem] provides an efficient *de novo* motif discovery algorithm for large-scale genomic sequence data.

The user may be interested in looking for unique signatures in the regions defined by `differentially methylated' to identify candidate transcription factors that could bind to these elements affected by the accumulation or absence of DNA methylation. For this analysis we use a sequence of 100 bases before and after the probe location (See lines 6-8 in the listing below).
An object will be returned which contains all relevant information about your motif analysis
(sequence consensus, pwm, chromosome, pvalue...).

```{r results='asis', echo=TRUE, message=FALSE,warning=FALSE}
library(rGADEM)
library(BSgenome.Hsapiens.UCSC.hg19)
library(motifStack)
library(rGADEM)
library(BSgenome.Hsapiens.UCSC.hg19)
library(motifStack)
probes <- rowRanges(met.chr9)[values(met.chr9)$status.GBM.LGG %in% c("Hypermethylated" ,"Hypomethylated") ,]
# Get hypo/hyper methylated probes and Make 200bp windows around it
sequence <- RangedData(space=as.character(probes@seqnames),
                       IRanges(start=probes@ranges@start - 100,
                               end=probes@ranges@start + 100), strand="*")
#look for motifs
gadem <- GADEM(sequence, verbose=FALSE, genome=Hsapiens)

# How many motifs were found?
length(gadem@motifList)

# get the number of occurences
nOccurrences(gadem)

# view all sequences consensus
consensus(gadem)

# Print the first two motif logos.
pwm <- getPWM(gadem)
pfm  <- new("pfm",mat=pwm[[2]],name="Novel Site 1")
plotMotifLogo(pfm)

# Number of instances of motif 1? 
length(gadem@motifList[[1]]@alignList)
```


After [rGADEM](http://bioconductor.org/packages/rGADEM/) returns it's results, the user can use [MotIV](http://bioconductor.org/packages/MotIV/)
package [@mercier2014motiv,@mahony2007dna,@mahony2007stamp,@mercier2011integrated]
to start the motif matching analysis. 

```{r results='asis', echo=TRUE,message=FALSE,warning=FALSE}
library(MotIV)
# motif matching analysis
analysis.jaspar <- motifMatch(pwm)
summary(analysis.jaspar)
plot(analysis.jaspar, ncol=2, top=5, rev=FALSE, main="", bysim=TRUE, cex=0.4)

#  visualize the quality of the results looking into the alignments
# E-value give an estimation of the match.
alignment <- viewAlignments(analysis.jaspar)
print(alignment[[1]])
```


## Integrative (Epigenomic \& Transcriptomic) analysis

Recent studies have shown that providing a deep integrative analysis can aid researchers in identifying and extracting biological insight from high through put data [@phillips2008role,@shi2014integrative,@rhodes2005integrative].
In this section, we will introduce a bioconductor package called [ELMER](http://bioconductor.org/packages/ELMER/) to identify regulatory enhancers using gene expression + DNA methylation data + motif analysis.  In addition, we show how to integrate the results from the previous sections with important epigenomic data derived from both the [ENCODE](http://www.encodeproject.org/) and [Roadmap](http://www.roadmapepigenomics.org/).

### Integration of DNA methylation \& gene expression data

After finding  differentially methylated CpG sites, one possible question one might ask is whether nearby genes also undergo a change in its expression, either an increase or a decrease.  DNA methylation at promoters of genes have been shown to be associated with silencing of the respective gene.

The starburst plot is proposed to combine information from two volcano plots, and is applied for a study of DNA methylation and gene expression [@noushmehr2010identification]. Even though, being desirable that both gene expression and DNA methylation data are from the same samples, the starburst plot can be applied as a meta-analysis tool, combining data from different samples [@siegmund2011statistical].

The function `TCGAvisualize_starburst`  creates a Starburst plot for comparison of DNA methylation
and gene expression. The $log_{10}$ (FDR-corrected P value) for DNA methylation is plotted on the x axis,
and for gene expression on the y axis, for each gene.
The horizontal black dashed line shows the FDR-adjusted P value of $10^{-100}$
for the expression data and the vertical ones shows the FDR-adjusted P value of $10^{-40}$ for the DNA methylation data.
While the argument met.p.cut and exp.p.cut controls the black dashed lines, the arguments
diffmean.cut and logFC.cut will be used to highlight the genes that respects these parameters
(circled genes in the figure). For the example below we set higher p.cuts trying
to get the most significant list of pair gene/probes. But for the next sections we will
use exp.p.cut = 0.01 and logFC.cut = 1 as the previous sections.

```{r results='asis', echo=TRUE, message=FALSE, warning=FALSE}
#------------------- Starburst plot ------------------------------
starburst <- TCGAvisualize_starburst(met.chr9,    # DNA methylation with results
                                     dataDEGs,    # DEG results
                                     "GBM","LGG", # Groups
                                     filename = "starburst.png",
                                     met.p.cut = 10^-2,
                                     exp.p.cut = 10^-2,
                                     diffmean.cut = 0.25,
                                     logFC.cut = 1,width = 15,height = 10,
                                     names = TRUE)
```

![](starburst.png)

### ChIP-seq analysis

ChIP-seq is used primarily to determine how transcription factors and other chromatin-associated
proteins influence phenotype-affecting mechanisms. Determining how proteins interact with DNA
 to regulate gene expression is essential for fully understanding many biological processes and disease states.
The aim is to explore significant overlap datasets for inferring co-regulation or
transcription factor complex for further investigation. A summary of the association
 of each histone mark is shown the in table below .
 

```{r table4, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "  
|                  Histone marks                 |                                                   Role                                                  |
|:----------------------------------------------:|:-------------------------------------------------------------------------------------------------------:|
| Histone H3 lysine 4 trimethylation (H3K4me3)   | Promoter regions [@heintzman2007distinct,@bernstein2005genomic]                                      |
| Histone H3 lysine 4 monomethylation (H3K4me1)  | Enhancer regions [@heintzman2007distinct]                                                           |
| Histone H3 lysine 36 trimethylation (H3K36me3) | Transcribed regions                                                                                     |
| Histone H3 lysine 27 trimethylation (H3K27me3) | Polycomb repression [@bonasio2010molecular]                                                         |
| Histone H3 lysine 9 trimethylation (H3K9me3)   | Heterochromatin regions  [@peters2003partitioning]                                                  |
| Histone H3 acetylated at lysine 27 (H3K27ac)   | Increase activation of genomic elements [@heintzman2009histone,@rada2011unique,@creyghton2010histone] |
| Histone H3 lysine 9 acetylation  (H3K9ac)      | Transcriptional activation [@nishida2006histone]                                                    |
"
cat(tabl) 
```

 Besides, ChIP-seq data exists in the ROADMAP database and can be obtained through the
 [AnnotationHub](http://bioconductor.org/packages/AnnotationHub/) package [@annotationHub]
 or from [Roadmap web portal](http://egg2.wustl.edu/roadmap/webportal/processed_data.html).
 The table below shows the description for all the roadmap files that are available through AnnotationHub.

```{r table5, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "  
|                File                |                               Description                              |
|:----------------------------------:|:----------------------------------------------------------------------:|
| fc.signal.bigwig                   | Bigwig File containing  fold enrichment signal tracks                  |
| pval.signal.bigwig                 | Bigwig File containing -log10(p-value) signal tracks                   |
| hotspot.fdr0.01.broad.bed.gz       | Broad domains on enrichment for  DNase-seq for consolidated epigenomes |
| hotspot.broad.bed.gz               | Broad domains on enrichment for DNase-seq for consolidated epigenomes  |
| broadPeak.gz                       | Broad ChIP-seq peaks for consolidated  epigenomes                      |
| gappedPeak.gz                      | Gapped ChIP-seq peaks for consolidated   epigenomes                    |
| narrowPeak.gz                      | Narrow ChIP-seq peaks for consolidated epigenomes                      |
| hotspot.fdr0.01.peaks.bed.gz       | Narrow DNasePeaks for   consolidated epigenomes                        |
| hotspot.all.peaks.bed.gz           | Narrow DNasePeaks for  consolidated epigenomes                         |
| .macs2.narrowPeak.gz               | Narrow DNasePeaks for consolidated epigenomes                          |
| coreMarks_mnemonics.bed.gz        | 15 state chromatin segmentations                                       |
| mCRF_FractionalMethylation.bigwig | MeDIP/MRE(mCRF) fractional methylation calls                           |
| RRBS_FractionalMethylation.bigwig | RRBS fractional methylation calls                                      |
| WGBS_FractionalMethylation.bigwig | Whole genome bisulphite fractional methylation calls                   |
"
cat(tabl) 
```

To help the user understand better the regions found in the DMR analysis, we
 downloaded histone marks specific for brain tissue, which was done using the
AnnotationHub package that can access Roadmap datababse. 
For a complete pipeline with Chip-seq data, bioconductor provides excellent tutorials to
work with ChIP-seq and we encourage our readers to review the following article [@ChIP-seqbioc].

The first step shown in listing below is to download the chip-seq data.
The function query received as argument the annotationHub database (ah) and a list of
keywords to be used for searching the data, *EpigenomeRoadmap* is selecting the
roadmap database, *consolidated* is selecting only the consolidate epigenomes,
*brain* is selecting the brain samples, E074 is one of the epigenomes for brain
(a table for the list is found in this
[summary table](https://docs.google.com/spreadsheets/d/1yikGx4MsO9Ei36b64yOy9Vb6oPC5IBGlFbYEt-N6gOM/edit#gid=15)
and narrowPeak is selecting the type of file.
The data downloaded is a processed data from  an integrative Analysis of 111 reference human epigenomes [@kundaje2015integrative].


```{r results='asis', echo=TRUE, message=FALSE,warning=FALSE}
library(ChIPseeker)
library(pbapply)
library(SummarizedExperiment)
library(GenomeInfoDb)
library(ggplot2)
library(AnnotationHub)

#------------------ Working with ChipSeq data ---------------
# Step 1: download histone marks for a brain and non-brain samples.
#------------------------------------------------------------
# loading annotation hub database
ah = AnnotationHub()

# Searching for brain consolidated epigenomes in the roadmap database
bpChipEpi_brain <- query(ah , c("EpigenomeRoadMap", "narrowPeak", "chip", "consolidated","brain","E068"))

# Get chip-seq data
histone.marks <-  pblapply(names(bpChipEpi_brain), function(x) {ah[[x]]})
names(histone.marks) <- names(bpChipEpi_brain)
```


The [Chipseeker](http://bioconductor.org/packages/ChIPseeker/) package  [@yu2015chipseeker]
implements functions that uses Chip-seq data to retrieve the nearest genes around the peak,
 to annotate genomic region of the peak, among others. Also, it provides several visualization
 functions to summarize the coverage of the peak, average profile and heatmap of peaks binding
 to TSS regions, genomic annotation, distance to TSS and overlap of peaks or genes.


After downloading the histone marks (see listing above),
it is useful to verify the average profile of peaks binding to hypomethylated and hypermethylated regions,
which will help the user understand better the regions found.

After, the Chipseeker was used to
visualize  how histone modifications are enriched to to hypomethylated and hypermethylated regions. 


```{r results='asis', echo=TRUE, message=FALSE,warning=FALSE}
library(ChIPseeker)
library(pbapply)
library(SummarizedExperiment)
library(GenomeInfoDb)
library(ggplot2)
library(AnnotationHub)

# Create a GR object based on the hypo/hypermethylated probes.
probes <- keepStandardChromosomes(rowRanges(met.chr9)[values(met.chr9)$status.GBM.LGG %in% c("Hypermethylated","Hypomethylated"),])
# Defining a window of 3kbp - 3kbp_probe_3kbp
probes@ranges <- IRanges(start = c(probes@ranges@start - 3000), end = c(probes@ranges@start + 3000))

### Profile of ChIP peaks binding to TSS regions
# First of all, for calculate the profile of ChIP peaks binding to TSS regions, we should
# prepare the TSS regions, which are defined as the flanking sequence of the TSS sites.
# Then align the peaks that are mapping to these regions, and generate the tagMatrix.
tagMatrixList <- pblapply(histone.marks, function(x) {
    getTagMatrix(keepStandardChromosomes(x), windows = probes, weightCol = "score")
})
names(tagMatrixList) <- basename(bpChipEpi_brain$title)
names(tagMatrixList) <- gsub(".narrowPeak.gz","",names(tagMatrixList)) # remove file type from name
names(tagMatrixList) <- gsub("E068-","",names(tagMatrixList)) # remove file type from name
```

To plot the enrichment heatmap use the function `tagHeatmap`
```{r results='asis', echo=TRUE, message=FALSE,warning=FALSE}
tagHeatmap(tagMatrixList, xlim=c(-3000, 3000),color = NULL)
```

To plot the  average profile of peaks binding to those region use `plotAvgProf`:
```{r results='asis', echo=TRUE, message=FALSE,warning=FALSE}
p <- plotAvgProf(tagMatrixList, xlim = c(-3000,3000), xlab = "Genomic Region (5'->3', centered on CpG)")
# We are centreing in the CpG instead of the TSS. So we'll change the labels manually
p <- p + scale_x_continuous(breaks=c(-3000,-1500,0,1500,3000),labels=c(-3000,-1500,"CpG",1500,3000))
library(ggthemes)
p + theme_few() + scale_colour_few(name="Histone marks") +guides(colour = guide_legend(override.aes = list(size=4)))
```

The hypomethylated and hypermethylated regions are enriched for H3K4me3,  H3K9ac, H3K27ac and H3K4me1
which indicates regions of enhancers, promoters and increased activation of genomic elements.
However, these regions are not associated neither with transcribed regions nor
Polycomb repression as the H3K36me3 and H3K27me3 heatmaps does not show an enrichment nearby the position 0,
and the average profile also does not show a peak at position 0.


To annotate the location of a given peak in terms of genomic features, annotatePeak
assigns peaks to genomic annotation in “annotation” column of the output, which includes
whether a peak is in the TSS, Exon, 5’ UTR, 3’ UTR, Intronic or Intergenic.

```{r results='asis', echo=TRUE, message=FALSE,warning=FALSE}
require(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
peakAnno <- annotatePeak(probes, tssRegion=c(-3000, 3000), TxDb=txdb, annoDb="org.Hs.eg.db",verbose = FALSE)
plotAnnoPie(peakAnno)
```


### Identification of Regulatory Enhancers


  Recently, many studies suggest that enhancers play a major role as regulators of
  cell-specific phenotypes leading to alteration in transcriptomes realated to
  diseases [@giorgio2015large,@groschel2014single,@sur2012mice,@yao2015demystifying}.
  In order to investigate regulatory enhancers that can be located at long distances
  upstream or downstream of target genes
 biocondcutor offer the [Enhancer Linking by Methylation/Expression Relationship (ELMER)](http://bioconductor.org/packages/ELMER/) package.
 This package is designed to combine DNA methylation and gene expression data
 from human tissues to infer multi-level cis-regulatory networks. It uses DNA methylation to identify enhancers
 and correlates their state with expression of nearby genes to identify one or more transcriptional targets.
 Transcription factor (TF) binding site analysis of enhancers is coupled with expression analysis of all TFs to infer upstream regulators.
 This package can be easily applied to TCGA public available cancer data sets
 and custom DNA methylation and gene expression data sets [@yao2015inferring].

ELMER analysis have 5 main steps:

1. Identify distal enhancer probes on HM450K.
2. Identify distal enhancer probes with significantly different DNA methyaltion level
in control group and experiment group.
3. Identify putative target genes for differentially methylated distal enhancer probes.
4. Identify enriched motifs for the distal enhancer probes which are significantly
differentially methylated and linked to putative target gene.
5. Identify regulatory TFs whose expression associate with DNA methylation at motifs.

This section shows how to use ELMER to analyze TCGA data using as example LGG and GBM samples.

### Preparing the data for ELMER package

After downloading the data with TCGAbiolinks package, some steps are still required to use TCGA data with ELMER.
These steps can be done with the function `TCGAprepare_elmer`. This function
for the DNA methylation data will remove probes with NA values in more than 20% samples and remove the annotation data,
for RNA expression data it will take the log2(expression + 1) of the expression matrix in order to linearize the relation between
DNA methylation and expression. Also, it will prepare the row names of the matrix as required by the package.

The listing below shows how to use
(http://bioconductor.org/packages/TCGAbiolinks/)[TCGAbiolinks}] [@TCGAbiolinks]
to search, download and prepare the data for the [ELMER](http://bioconductor.org/packages/ELMER/) package.
Due to time and memory constraints, we will use in this example only data from 10 LGG patients  and 10 GBM patients that 
have both DNA methylation and gene expression data. This samples are the same used in the previous steps.

```{#numCode .R .numberLines}
#--------------------- 8.3 Identification of Regulatory Enhancers   ----------------------------
library(TCGAbiolinks)
library(stringr)
# Samples: primary solid tumor with both DNA methylation and gene expression
matched_met_exp <- function(tumor, n = NULL){
    # get primary solid tumor samples: DNA methylation
    met450k <- TCGAquery(tumor = tumor,"HumanMethylation450", level = 3)
    met450k.tp <- TCGAquery_SampleTypes(unique(unlist(stringr::str_split(met450k$barcode,","))),c("TP"))

    # get primary solid tumor samples: RNAseq
    rnaseq <- TCGAquery(tumor = tumor,c("IlluminaHiSeq_RNASeqV2"),level = 3)
    rnaseq.tp <- TCGAquery_SampleTypes(unique(unlist(stringr::str_split(rnaseq$barcode,","))),c("TP"))

    # Get samples with samples in both platforms
    samples <- unique(substr(rnaseq.tp,1,15)[substr(rnaseq.tp,1,12) %in% substr(met450k.tp,1,12)] )
    if(!is.null(n)) samples <- samples[1:n] # get only n samples
    return(samples)
}
lgg.samples <- matched_met_exp("LGG", n = 10)
gbm.samples <- matched_met_exp("GBM", n = 10)
samples <- c(lgg.samples,gbm.samples)

#-----------------------------------
# 1 - Methylation
# ----------------------------------
# For methylation it is quicker in this case to download the tar.gz file
# and get the samples we want instead of downloading files by files
query.met <- TCGAquery(tumor = c("GBM","LGG"), platform = "HumanMethylation450", level = 3, samples = samples)
TCGAdownload(query.met, samples = samples)
met.elmer <- TCGAprepare(query.met,dir = ".", save = FALSE,samples = samples)
met.elmer <- TCGAprepare_elmer(met.elmer, platform = "HumanMethylation450")

#-----------------------------------
# 2 - Expression
# ----------------------------------
query.rna <- TCGAquery(tumor = c("GBM","LGG"), platform = "IlluminaHiSeq_RNASeqV2", level = 3)
TCGAdownload(query.rna, samples = samples, type = "rsem.genes.normalized_results")
exp.elmer <- TCGAprepare(query.rna,dir = ".", ,type = "rsem.genes.normalized_results",
                         samples =  samples, save = FALSE)
exp.elmer <- TCGAprepare_elmer(exp.elmer, platform = "IlluminaHiSeq_RNASeqV2")
```


Finally, the ELMER input is a mee object that contains a DNA methylation matrix, an gene expression matrix,
a probe information GRanges, the gene information GRanges and a data frame summarizing the data.
It should be highlighted that samples without both the gene expression and DNA methylation data will be removed from the mee object.

By default the function `fetch.mee` that is used to create the mee will separate the samples into two
groups, the control group (normal samples) and the experiment group (tumor samples), but the user can relabel the
samples to compare different groups. For the next sections, we will work with two groups the experiment group (GBM)
and control samples (LGG).

```{#numCode .R .numberLines}
library(ELMER)
geneAnnot <- txs()
geneAnnot$GENEID <- paste0("ID",geneAnnot$GENEID)
geneInfo <- promoters(geneAnnot,upstream = 0, downstream = 0)
probe <- get.feature.probe()

# create mee object, use @ to access the matrices inside the object
mee <- fetch.mee(meth = met.elmer, exp = exp.elmer, TCGA = TRUE, probeInfo = probe, geneInfo = geneInfo)

# Get lgg barcodes
samples <- unlist(str_split(TCGAquery("gbm", "HumanMethylation450", level = 3)$barcode,","))

# Relabel LGG samples in the mee object: LGG is control
mee@sample$TN[mee@sample$ID %in% lgg.samples] <- "Control"
save(mee,file = "mee.rda")
```


### ELMER analysis
After preparing the data into a mee object, we executed the five ELMER steps for both the hypo
(distal enhancer probes hypomethylated in the GBM group) and hyper (distal enhancer probes hypermethylated in the GBM group) direction.
The code is shown below. A description of how these distal enhacer probes are identified is found in
 the [ELMER.data](https://bioconductor.org/packages/release/data/experiment/vignettes/ELMER.data/inst/doc/vignettes.pdf) vignette.

```{#numCode .R .numberLines}
library(parallel)
# Available directions are hypo and hyper, we will use only hypo
# due to speed constraint
direction <- c("hypo")

for (j in direction){
    print(j)
    dir.out <- paste0("elmer/",j)
    dir.create(dir.out, recursive = TRUE)
    #--------------------------------------
    # STEP 3: Analysis                     |
    #--------------------------------------
    # Step 3.1: Get diff methylated probes |
    #--------------------------------------
    Sig.probes <- get.diff.meth(mee, cores=detectCores(),
                                dir.out =dir.out,
                                diff.dir=j,
                                pvalue = 0.01)

    #-------------------------------------------------------------
    # Step 3.2: Identify significant probe-gene pairs            |
    #-------------------------------------------------------------
    # Collect nearby 20 genes for Sig.probes
    nearGenes <- GetNearGenes(TRange=getProbeInfo(mee, probe=Sig.probes$probe),
                              cores=detectCores(),
                              geneAnnot=getGeneInfo(mee))

    pair <- get.pair(mee=mee,
                     probes=Sig.probes$probe,
                     nearGenes=nearGenes,
                     permu.dir=paste0(dir.out,"/permu"),
                     dir.out=dir.out,
                     cores=detectCores(),
                     label= j,
                     permu.size=100, # For significant results use 10000
                     Pe = 0.01) # For significant results use 0.001

    Sig.probes.paired <- fetch.pair(pair=pair,
                                    probeInfo = getProbeInfo(mee),
                                    geneInfo = getGeneInfo(mee))
    Sig.probes.paired <-read.csv(paste0(dir.out,"/getPair.",j,".pairs.significant.csv"),
                                 stringsAsFactors=FALSE)[,1]


    #-------------------------------------------------------------
    # Step 3.3: Motif enrichment analysis on the selected probes |
    #-------------------------------------------------------------
    if(length(Sig.probes.paired) > 0 ){
        #-------------------------------------------------------------
        # Step 3.3: Motif enrichment analysis on the selected probes |
        #-------------------------------------------------------------
        enriched.motif <- get.enriched.motif(probes=Sig.probes.paired,
                                             dir.out=dir.out, label=j,
                                             background.probes = probe$name)
        motif.enrichment <- read.csv(paste0(dir.out,"/getMotif.",j,".motif.enrichment.csv"),
                                     stringsAsFactors=FALSE)
        if(length(enriched.motif) > 0){
            #-------------------------------------------------------------
            # Step 3.4: Identifying regulatory TFs                        |
            #-------------------------------------------------------------
            print("get.TFs")

            TF <- get.TFs(mee = mee,
                          enriched.motif = enriched.motif,
                          dir.out = dir.out,
                          cores = detectCores(), label = j)
            TF.meth.cor <- get(load(paste0(dir.out,"/getTF.",j,".TFs.with.motif.pvalue.rda")))
            save(TF, enriched.motif, Sig.probes.paired,
                 pair, nearGenes, Sig.probes, motif.enrichment, TF.meth.cor,
                 file=paste0(dir.out,"/ELMER_results_",j,".rda"))
        }
    }
}
```
When ELMER Identifies the enriched motifs for the distal enhancer probes which are significantly
differentially methylated and linked to putative target gene, it will plot the Odds Ratio (x axis) for the each motifs found.

The list of motifs found for the hyper direction (probes hypomethylated in LGG group compared to the GBM group)
is found in the motif enrichment plot. 

```{r, echo=TRUE, message=FALSE, warnings=FALSE, results='asis',fig.height=10}
 motif.enrichment.plot(motif.enrichment=motif.enrichment,save = FALSE)
```

To select the motifs we select the motifs that had a minimum incidence
of 10 in the given probes set and the smallest lower boundary of 95% confidence interval for Odds Ratio of 1.1.
These both values are the default from the ELMER package.

```{r, echo=TRUE, message=FALSE, warnings=FALSE, results='asis'}
# The analysis found  how many enriched motifs for the hypo direction?
length(TF$motif)
```


```{r tableTF, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
library(knitr)
kable(TF)
```

After finding these list of enriched motifs, ELMER Identifies regulatory TFs whose expression
associate with DNA methylation at motifs and for each enriched motif a TF ranking plot is created
automatically by ELMER. This plot shows the TF ranking plots based on the score $(-log(P value))$ of association between
TF expression and DNA methylation of the motif. We can see in figure \ref{tfrank} that the top 3 associated
TFs that are associated with that AP1 motif are  POLR3K, DLX3 and NEUROD2.


```{r results='asis', echo=TRUE, message=FALSE,warning=FALSE, fig.align='center',fig.height=8,fig.width=8}
library(ELMER)
library(grid)
load("/home/tiagochst/elmer/hypo/ELMER_results_hypo.rda")
gg <- TF.rank.plot(motif.pvalue=TF.meth.cor, motif="AP1", save=FALSE)
grid.draw(gg[[1]])
```	


The output of this step is a data frame with the following columns:

* **motif:**  the names of motif.
* **top.potential.TF:** the highest ranking upstream TFs which are known recognized the motif.
* **potential.TFs:**  TFs which are within top 5% list and are known recognized the motif.
top5percent:  all TFs which are within top 5% list considered candidate upstream regulators

Also, for each motif we can take a look on the three most relevant transcription factors.
For example, for the AP1 motif the average DNA methylation level of sites with the AP1 motif
plotted against the expression of the transcription factors WT1, ZNF208, ATF4 and DDX5 is show in figure \ref{tfvsmet}.
 We can see that the experiment group (GBM samples) has a lower average methylation level of sites with the AP1 motif
 plotted and a higher  expression of the transcription factors.

```{#numCode .R .numberLines}
scatter.plot(mee, category="TN", save=T, lm_line=TRUE,
             byTF=list(TF=c("WT1","ZNF208","ATF4","DDX5"), probe=enriched.motif[["AP1"]]))
```

![](TF.png)

 And for each relevant TF we will use the clinical data to analyze the survival curves for the 30% patients with higher expression of that transcription factor versus the 30% with lower expression. The code below shows that analysis.

```{#numCode .R .numberLines}

TCGAsurvival_TFplot <- function(TF,mee, clinical, percentage = 0.3){

    # For the transcription factor, gets it getGeneID
    gene <- getGeneID(mee,symbol=TF)
    # Get the expression values for the genes.
    # (getExp is a ELMER function)
    exp <- getExp(mee,geneID=gene)

    # Get the names of the 30% patients with lower expression
    g1 <- names(sort(exp)[1:ceiling(length(exp) * percentage)])

    # Get the names of the 30% patients with higher expression
    g2 <- names(sort(exp,decreasing = T)[1:ceiling(length(exp) * percentage)])

    # get the data of only these patients
    clinical <- clinical[clinical$bcr_patient_barcode %in% substr(c(g1, g2),1,12),]

    # Create the labels for each sample
    clinical$tf_groups <- "high"
    clinical[clinical$bcr_patient_barcode  %in% substr(c(g1),1,12),]$tf_groups <- "low"

    # Use TCGAbiolinks to create the survival curve
    TCGAanalyze_survival(clinical,"tf_groups",
                         legend=paste0(TF," Exp level"),
                         filename = paste0(TF,".png"))
}

# get clinical patient data for GBM samples
gbm_clin <- TCGAquery_clinic("gbm","clinical_patient")

# get clinical patient data for LGG samples
lgg_clin <- TCGAquery_clinic("lgg","clinical_patient")

# Bind the results, as the columns might not be the same,
# we will will plyr rbind.fill, to have all columns from both files
clinical <- plyr::rbind.fill(gbm_clin,lgg_clin)
# Call the function we created
TCGAsurvival_TFplot("FOXP4",mee,clinical)
TCGAsurvival_TFplot("FOXE3",mee,clinical)
```

The figures \ref{survival_hoxa6}, shows that the samples with lower expression of these TFs have a better survival than those with higher expression.

![](FOXE3.png)
![](FOXP4.png)



# Conclusion

This workflow outlines how one can use specific Bioconductor packages for the
analysis of cancer genomics and epigenomics data derived from the TCGA.
 In addition, we highlight the importance of using ENCODE and Roadmap data
 to inform on the biology of the non-coding elements defined by functional
 roles in gene regulation. We introduced [TCGAbiolinks](http://www.bioconductor.org/packages/TCGAbiolinks/)
 and  [RTCGAtoolbox](http://www.bioconductor.org/packages/RTCGAtoolbox/) bioconductor packages
 in order to illustrate how one can acquire TCGA specific data, followed by key steps for
 genomics analysis using [GAIA](http://www.bioconductor.org/packages/gaia/) package, for
 transcriptomic analysis using [TCGAbiolinks](http://www.bioconductor.org/packages/TCGAbiolinks/),
 dnet, [pathview](http://www.bioconductor.org/packages/pathview/) packages and for DNA methylation analysis
 using  [TCGAbiolinks](http://www.bioconductor.org/packages/TCGAbiolinks/) package.
 An inference of gene regulatory networks was also introduced by  [MINET](http://www.bioconductor.org/packages/minet/)
 package. Finally, we introduced bioconductor packages
[AnnotationHub](http://www.bioconductor.org/packages/AnnotationHub/),
 [ChIPSeeker](http://www.bioconductor.org/packages/ChIPseeker/),
 [ComplexHeatmap](http://www.bioconductor.org/packages/ComplexHeatmap/),
  and [ELMER](http://www.bioconductor.org/packages/ELMER/)
  to illustrate how one can acquire ENCODE/Roadmap data and integrate with
  the results obtained from analyzing TCGA data in order to identify and
  characterize candidate regulatory enhancers associated with cancer.

# Software availability

This workflow depends on various packages from version 3.3 of the Bioconductor project,
running on R version 3.3.0 or higher.
It requires a number of software packages,
including 
 [AnnotationHub](http://www.bioconductor.org/packages/AnnotationHub/),
 [ChIPSeeker](http://www.bioconductor.org/packages/ChIPseeker/),
 [ComplexHeatmap](http://www.bioconductor.org/packages/ComplexHeatmap/),
 [pathview](http://www.bioconductor.org/packages/pathview/),
 [ELMER](http://www.bioconductor.org/packages/ELMER/),
 [GAIA](http://www.bioconductor.org/packages/gaia/),
 [MINET](http://www.bioconductor.org/packages/minet/),
 [RTCGAtoolbox](http://www.bioconductor.org/packages/RTCGAtoolbox/),
and [TCGAbiolinks](http://www.bioconductor.org/packages/TCGAbiolinks/)


```{r, eval = FALSE}
source("https://bioconductor.org/biocLite.R")
packages <- c("TCGAbiolinks","ELMER","gaia","ChIPseeker","AnnotationHub",
              "ComplexHeatmap", "clusterProfiler", "RTCGAToolbox",
              "minet","biomaRt","pathview", "MotifDb", "MotIV","motifStack",
              "rGADEM","BSgenome.Hsapiens.UCSC.hg19")
new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) biocLite(new.packages)
if(!require("dnet")) install.packages("dnet")
if(!require("circlize")) install.packages("circlize")
if(!require("VennDiagram")) install.packages("VennDiagram")
if(!require("c3net")) install.packages("c3net")
if(!require("pbapply")) install.packages("pbapply")
if(!require("gplots")) install.packages("gplots")
```


```{r}
sessionInfo()
```

# References
